From a1a9bdd20de1556a84271294a795a7c2ea9a3f67 Mon Sep 17 00:00:00 2001
From: gsd <913887524@qq.com>
Date: Thu, 25 Jan 2024 17:36:32 +0800
Subject: [PATCH] feat: refactor bootloader and makefile 1. mbr just care
 bootable sign 2. group constants in assemble file 3. loader store device info
 to designated address 4. replace some code in loader with C 5.  loader can
 adapt to dynamic kernel entry and bigger kernel 6. now kernel are loaded to
 0xc0020000 7. before creating memory allocator, kernel will check if
 allocator will cover kernel elf 8. introduce some macro in `stddef.h` 9.
 makefile will create deps for assemble file 10. remove unnecessary target in
 makefile 11. add target to monitor real mode

---
 .vscode/settings.json          |    1 +
 boot/boot.asm                  |  738 +++++++----------------
 boot/include/boot.inc          |    6 +
 boot/include/fat32.inc         |  106 ++--
 boot/include/lib.inc           |  170 ------
 boot/include/loader.inc        |   77 +--
 boot/include/mbr.inc           |   14 +
 boot/include/packet.inc        |    6 +
 boot/include/pm.inc            |   68 +--
 boot/loader.asm                | 1014 --------------------------------
 boot/loader/linker.ld          |   31 +
 boot/loader/load_kernel.c      |  272 +++++++++
 boot/loader/loader_protect.asm |   32 +
 boot/loader/loader_real.asm    |   93 +++
 boot/loader/setup_paging.c     |   71 +++
 boot/mbr.asm                   |  373 ++++--------
 include/fs/fat.h               |   36 +-
 include/kernel/arch/device.h   |   18 +
 include/kernel/config.h.in     |    6 +
 include/kernel/unios/elf.h     |   67 +--
 include/lib/stddef.h           |   31 +-
 kernel/memory.c                |    9 +-
 project/conf-gdb.mk            |    2 +
 project/conf-unios.mk          |   14 +-
 project/prepare-boot.mk        |   23 +-
 project/prepare-fs_flags.mk    |    7 +-
 project/prepare.mk             |    4 -
 project/rules-asbin.mk         |   10 +-
 project/rules-gen.mk           |   26 +-
 project/rules-image.mk         |   13 +-
 project/rules-kernel.mk        |    7 +-
 project/rules-obj.mk           |    6 +-
 project/rules.mk               |   13 +-
 33 files changed, 1149 insertions(+), 2215 deletions(-)
 create mode 100644 boot/include/boot.inc
 delete mode 100644 boot/include/lib.inc
 create mode 100644 boot/include/mbr.inc
 create mode 100644 boot/include/packet.inc
 delete mode 100644 boot/loader.asm
 create mode 100644 boot/loader/linker.ld
 create mode 100644 boot/loader/load_kernel.c
 create mode 100644 boot/loader/loader_protect.asm
 create mode 100644 boot/loader/loader_real.asm
 create mode 100644 boot/loader/setup_paging.c
 create mode 100644 include/kernel/arch/device.h

diff --git a/.vscode/settings.json b/.vscode/settings.json
index 5b48c09..74a6962 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -20,6 +20,7 @@
         "-I${workspaceFolder}/include/kernel",
         "-I${workspaceFolder}/include/lib",
         "-I${workspaceFolder}/include/deps",
+        "-I${workspaceFolder}/include/fs",
         "-I${workspaceFolder}/build/include",
         "-Wno-unknown-attributes",
     ],
diff --git a/boot/boot.asm b/boot/boot.asm
index c73fe76..bce19d1 100644
--- a/boot/boot.asm
+++ b/boot/boot.asm
@@ -1,543 +1,229 @@
-;==============================================================================================================================
-BaseOfStack			equ		0x07c00		; Boot状态下堆栈基地址
-STACK_ADDR  		equ  	0x7bea 		; 堆栈栈顶
-
-BaseOfBoot 					equ	1000h 		; added by mingxuan 2020-9-12
-OffsetOfBoot				equ	7c00h		; load Boot sector to BaseOfBoot:OffsetOfBoot
-OffsetOfActiPartStartSec	equ 7e00h		; 活动分区的起始扇区号相对于BaseOfBoot的偏移量	;added by mingxuan 2020-9-12 
-											; 该变量来自分区表，保存在该内存地址，用于在os_boot和loader中查找FAT32文件
-
-BOOT_FAT32_INFO		equ		0x5A		;位于boot中的FAT32配置信息的长度
-										;added by mingxuan 2020-9-16
-
-DATA_BUF_OFF 		equ  	0x2000		; 目录 被加载的缓冲区地址
-
-OSLOADER_SEG 		equ  	0x09000 	; 起始段地址     
-OSLOADER_SEG_OFF	equ		0x0100
-
-;FAT_START_SECTOR 	equ  	0x820	  	; FAT表的起始扇区号  DWORD
-;FAT_START_SECTOR 	equ  	0x1020	  	; FAT表的起始扇区号  DWORD ; for test 2020-9-10, mingxuan
-;DATA_START_SECTOR 	equ  	0xd6a	  	; 数据区起始扇区号  DWORD
-;DATA_START_SECTOR 	equ  	0x156a	  	; 数据区起始扇区号  DWORD ; for test 2020-9-10, mingxuan
-;DATA_START_SECTOR 	equ  	0x13a4	  	; 数据区起始扇区号  DWORD ; for test 2020-9-13, mingxuan
-
-DIR_PER_SECTOR  	equ  	0x10  		; 每个扇区所容纳的目录 BYTE
-
-; 扩展磁盘服务所使用的地址包
-DAP_SECTOR_HIGH  	equ  	4  			; 起始扇区号的高32位 ( 每次调用需要重置 ) DWORD
-DAP_SECTOR_LOW  	equ  	8  			; 起始扇区号的低32位 ( 每次调用需要重置 ) DWORD
-
-DAP_BUFFER_SEG  	equ  	10  		; 缓冲区段地址   ( 每次调用需要重置 ) WORD
-DAP_BUFFER_OFF  	equ  	12  		; 缓冲区偏移   ( 每次调用需要重置 ) WORD  
-
-DAP_RESERVED2  		equ  	13  		; 保留字节
-
-DAP_READ_SECTORS 	equ  	14  		; 要处理的扇区数(1 - 127 )
-DAP_RESERVED1  		equ  	15  		; 保留字节
-DAP_PACKET_SIZE  	equ  	16  		; 包的大小为16字节
-
-CURRENT_CLUSTER  	equ  	20  		; 当前正在处理的簇号 DWORD
-
-; 目录项结构
-OFF_START_CLUSTER_HIGH  equ  	20  		; 起始簇号高位  WORD
-OFF_START_CLUSTER_LOW  	equ  	26  		; 起始簇号低位  WORD
-
-; 相关常量
-DIR_NAME_FREE    	equ  	0x00  		; 该项是空闲的
-DIR_ENTRY_SIZE    	equ  	32  		; 每个目录项的尺寸
-
-; 簇属性
-CLUSTER_MASK    	equ  	0FFFFFFFH 	; 簇号掩码
-CLUSTER_LAST    	equ  	0FFFFFF8H   	;0xFFFFFFF8-0xFFFFFFFF表示文件的最后一个簇
-
-; added by mingxuan 2020-9-12
-BPB_BytesPerSec	    equ		(OffsetOfBoot + 0xb)	;每扇区字节数
-BPB_SecPerClu 		equ		(OffsetOfBoot + 0xd)	;每簇扇区数 
-BPB_RsvdSecCnt		equ		(OffsetOfBoot + 0xe)	;保留扇区数
-BPB_NumFATs			equ		(OffsetOfBoot + 0x10)	;FAT表数
-BPB_RootEntCnt		equ 	(OffsetOfBoot + 0x11)	;FAT32不使用
-BPB_TotSec16		equ		(OffsetOfBoot + 0x13)	;扇区总数
-BPB_Media			equ 	(OffsetOfBoot + 0x15)	;介质描述符
-BPB_FATSz16			equ		(OffsetOfBoot + 0x16)	;每个FAT表的大小扇区数(FAT32不使用)
-BPB_SecPerTrk		equ		(OffsetOfBoot + 0x18)	;每磁道扇区数
-BPB_NumHeads		equ		(OffsetOfBoot + 0x1a)	;磁头数
-BPB_HiddSec			equ	    (OffsetOfBoot + 0x1c)	;分区已使用扇区数
-BPB_TotSec32		equ		(OffsetOfBoot + 0x20)	;文件系统大小扇区数
-	
-BS_SecPerFAT		equ		(OffsetOfBoot + 0x24)	;每个FAT表大小扇区数
-BS_Flag				equ		(OffsetOfBoot + 0x28)	;标记
-BS_Version			equ		(OffsetOfBoot + 0x2a)	;版本号
-BS_RootClus			equ		(OffsetOfBoot + 0x2c)	;根目录簇号
-BS_FsInfoSec 		equ		(OffsetOfBoot + 0x30)	;FSINFO扇区号
-BS_BackBootSec 		equ	    (OffsetOfBoot + 0x32)	;备份引导扇区位置
-BS_Unuse1			equ		(OffsetOfBoot + 0x34)	;未使用
-;BS_Unuse2			equ		(OffsetOfBoot + 0x40)	;未使用	;deleted by mingxuan 2020-9-15
-;BS_Unuse3			equ 	(OffsetOfBoot + 0x41)	;未使用	;deleted by mingxuan 2020-9-15
-BS_DriveNum			equ		(OffsetOfBoot + 0x40)	;设备号
-BS_Unuse4			equ		(OffsetOfBoot + 0x41)	;未使用
-BS_ExtBootFlag		equ		(OffsetOfBoot + 0x42)	;扩展引导标志
-BS_VolNum			equ		(OffsetOfBoot + 0x43)	;卷序列号
-BS_VolName			equ		(OffsetOfBoot + 0x47)	;卷标
-;==============================================================================================================================
-	;org	07c00h	;deleted by mingxuan 2020-9-16
-	org		(07c00h + BOOT_FAT32_INFO)  ;FAT322规范规定第90~512个字节(共423个字节)是引导程序
-										;modified by mingxuan 2020-9-16
-
-	;jmp	START		;deleted by mingxuan 2020-9-15
-	;nop				;deleted by mingxuan 2020-9-15
-
-	FAT_START_SECTOR 	DD 	0 ;FAT表的起始扇区号 ;added by mingxuan 2020-9-17
-	DATA_START_SECTOR 	DD  0 ;数据区起始扇区号 ;added by mingxuan 2020-9-17
-
-;deleted by mingxuan 2020-9-12
-	;BS_OEM			DB	'mkfs.fat'	;文件系统标志
-
-	;BPB_BytesPerSec	DW	0x200		;每扇区字节数
-	;BPB_SecPerClu 	DB	1			;每簇扇区数 
-	;BPB_RsvdSecCnt	DW	0x20		;保留扇区数
-	;BPB_NumFATs		DB	2			;FAT表数
-	;BPB_RootEntCnt	DW 	0			;FAT32不使用
-	;BPB_TotSec16	DW	0			;扇区总数
-	;BPB_Media		DB 	0xf8		;介质描述符
-	;BPB_FATSz16		DW	0			;每个FAT表的大小扇区数
-	;BPB_SecPerTrk	DW	0x3f		;每磁道扇区数
-	;BPB_NumHeads	DW	0xff		;磁头数
-	;BPB_HiddSec		DD	0			;分区已使用扇区数
-	;BPB_TotSec32	DD	0x015791	;文件系统大小扇区数
-	
-	;BS_SecPerFAT	DD	0x02a5		;每个FAT表大小扇区数
-	;BS_Flag			DW	0			;标记
-	;BS_Version		DW	0			;版本号
-	;BS_RootClus		DD	2			;根目录簇号
-	;BS_FsInfoSec 	DW	1			;FSINFO扇区号
-	;BS_BackBootSec 	DW	6			;备份引导扇区位置
-	;BS_Unuse1		DD	0			;未使用
-	;BS_Unuse2		DD	0			;未使用
-	;BS_Unuse3		DD 	0			;未使用
-	;BS_DriveNum		DB	0x80		;设备号
-	;BS_Unuse4		DB	0x01		;未使用
-	;BS_ExtBootFlag	DB	0x29		;扩展引导标志
-	;BS_VolNum		DD	0xbe3a8ff5	;卷序列号
-	;BS_VolName		DB	'MZY hd boot'	;卷标
-
-START:	
-	cld
-	mov    	ax, cs
+%include "mbr.inc"
+%include "boot.inc"
+%include "loader.inc"
+OffsetOfBPB	equ OffsetOfBoot
+%include "fat32.inc"
+%include "packet.inc"
+
+org	EndOfBPB
+; 当MBR将执行权交给boot时，它会将dl设置为使用的驱动器号，注意不要将其覆盖了
+; 与此同时需要注意ds:si指向的是启动分区对应的MBR项，需要先将其拷贝进来
+Start:
+	mov		ax, cs
+	mov		ebx, [ds:si + MBRFirstLBA]
 	mov		ds, ax
-	mov		es, ax ;deleted by mingxuan 2020-9-13
 	mov		ss, ax
-
-	; 清屏
-	; for test, added by mingxuan 2020-9-15
-	; pusha
-	; mov		dx, 0184fh		; 右下角: (80, 50)
-	; int		10h				; int 10h
-	; popa
-
-	;added by mingxuan 2020-9-13
-	;mov		ax, BaseOfBoot
-	;mov		fs, ax 			;es存储BaseOfBoot，用于查找FAT32的配置信息
-
-	;FAT_START_SECTOR  DD 	([fs:OffsetOfActiPartStartSec] + [fs:BPB_RsvdSecCnt]) 
-	; 计算FAT表的起始扇区号 ; added by mingxuan 2020-9-17
-	mov		eax, [ OffsetOfActiPartStartSec]
-	add		ax, [ BPB_RsvdSecCnt ]
-	mov 	[FAT_START_SECTOR], eax
-	; 计算数据区起始扇区号 ; added by mingxuan 2020-9-17
-	add		eax, [BS_SecPerFAT]
-	add		eax, [BS_SecPerFAT]
-	mov		[DATA_START_SECTOR], eax
-
-	mov		sp, STACK_ADDR
-	mov  	bp, BaseOfStack
-
-	mov 	dword [bp - DAP_SECTOR_HIGH ],	00h
-	;mov 	byte  [bp - DAP_RESERVED1   ], 	00h ;deleted by mingxuan 2020-9-17
-	;mov 	byte  [bp - DAP_RESERVED2   ], 	00h ;deleted by mingxuan 2020-9-17
-	mov 	byte  [bp - DAP_PACKET_SIZE ], 	10h
-	mov		byte  [bp - DAP_READ_SECTORS],  01h
-	mov		word  [bp - DAP_BUFFER_SEG  ],	01000h
-
-	;for test, added by mingxuan 2020-9-4
-	;call 	DispStr		; 
-	;jmp		$
-
-	jmp		_SEARCH_LOADER
-
-
-_MISSING_LOADER:     ; 显示没有装载程序
-	;for test, added by mingxuan 2020-9-10
-	;call 	DispStr		; 
-	;JMP  	$ ;for test, added by mingxuan 2020-9-10
-
-	; 清屏
-	; for test, added by mingxuan 2020-9-15
-	;pusha
-	;mov		dx, 0184fh		; 右下角: (80, 50)
-	;int		10h				; int 10h
-	;popa
-
-_DISK_ERROR:      	 ; 显示磁盘错误信息
-	;for test, added by mingxuan 2020-9-4
-
-	; 清屏
-	; for test, added by mingxuan 2020-9-15
-	;pusha
-	;mov		dx, 0184fh		; 右下角: (80, 50)
-	;int		10h				; int 10h
-	;popa
-
-	JMP  	$
-
-ReadSector:
+	mov		es, ax
+	; 初始化其余段寄存器，在初始化完之后才能正确访存
+	jmp		Init
+
+;============================================================================
+;变量
+;----------------------------------------------------------------------------
+DriverNumber	db 0		; 驱动器号的临时存储位置
+EndOfBuffer		dw 0		; buffer段的末尾地址
+SecOfDataZone	dd 0		; 数据区基扇区号
+PartitionLBA	dd 0		; 分区起始LBA
+;============================================================================
+;字符串
+;----------------------------------------------------------------------------
+LoaderName                db    "LOADER  BIN"
+; 为简化代码, 下面每个字符串的长度均为 MessageLength
+MessageLength             equ   9
+Message0                  db    "Read Fail"
+Message1                  db    "No Loader"
+;============================================================================
+
+
+;----------------------------------------------------------------------------
+; 函数名: DispStr
+;----------------------------------------------------------------------------
+; 作用:
+;    显示一个字符串, 函数开始时 dh 中应该是字符串序号(从0开始)
+DispStr:
 	pusha
-	
-	mov		ah, 42h						;ah是功能号，扩展读对应0x42
-	lea 	si, [BP - DAP_PACKET_SIZE]  ;使用扩展int13时DAP结构体首地址传给si
-	
-	;mov	dl, [BS_DriveNum]			;deleted by mingxuan 2020-9-13
-	;mov	es, BaseOfBoot 				;modified by mingxuan 2020-9-13
-	;mov	dl, [fs:BS_DriveNum]		;modified by mingxuan 2020-9-13
-	mov		dl, [BS_DriveNum]		;modified by mingxuan 2020-9-17
-	;mov	dl, 0x80
-
-	;jmp 	$
-
-	int 	13h
-
-	jc 		_DISK_ERROR
-
-	;jmp	$
+	push	es
+
+	mov		ax, MessageLength
+	mul		dh
+	add		ax, Message0
+	mov		bp, ax
+	mov		ax, ds
+	mov		es, ax            ; ES:BP = 串地址
+	mov		cx, MessageLength ; CX = 串长度
+	mov		ax, 01301h        ; AH = 13,  AL = 01h
+	mov		bx, 0007h         ; 页号为0(BH = 0) 黑底白字(BL = 07h)
+	mov		dl, 0
+	int		10h
+
+	pop		es
+	popa
+	ret
 
-	; 清屏
-	; for test, added by mingxuan 2020-9-15
-	;pusha
-	;mov		dx, 0184fh		; 右下角: (80, 50)
-	;int		10h				; int 10h
-	;popa
+;----------------------------------------------------------------------------
+; 函数名: ReadSector
+;----------------------------------------------------------------------------
+; 作用:
+;    将磁盘的数据读入到内存中
+;    eax: 从哪个扇区开始
+;    cx: 读入多少个扇区
+;    (es:bx): 读入的缓冲区的起始地址
+ReadSector:
+	pushad
+	sub		sp, SizeOfPacket
+
+	mov		si, sp
+	mov		word [si + Packet_BufferPacketSize], SizeOfPacket
+	mov		word [si + Packet_Sectors], cx
+	mov		word [si + Packet_BufferOffset], bx
+	mov		word [si + Packet_BufferSegment], es
+	add		eax, [PartitionLBA]
+	mov		dword [si + Packet_StartSectors], eax
+	mov		dword [si + Packet_StartSectors + 4], 0
+
+	mov		dl, [DriverNumber]
+	mov		ah, 42h		; 扩展读
+	int		13h
+	jc		.ReadFail	; 读取失败，简单考虑就默认bios坏了
+
+	add		sp, SizeOfPacket
+	popad
+	ret
 
+.ReadFail:
+	mov		dh, 0
+	call	DispStr
+	jmp	$		; 如果cf位置1，就意味着读入错误，这个时候建议直接开摆
+
+;----------------------------------------------------------------------------
+; 函数名: ReadCluster
+;----------------------------------------------------------------------------
+; 作用:
+;    读取簇号对应的一整个簇
+;    eax: 当前簇号
+;    (es:bx): 读入的缓冲区的起始地址
+ReadCluster:
+	pushad
+
+	sub		eax, CLUSTER_Base
+	movzx	ecx, byte [BPB_SecPerClus]
+	mul		ecx
+	add		eax, [SecOfDataZone]
+	call	ReadSector
 
-	popa
+	popad
 	ret
 
-_SEARCH_LOADER:
-	mov		word [bp - DAP_BUFFER_OFF], DATA_BUF_OFF
-	
-	;mov	eax, dword [BS_RootClus]		;deleted by mingxuan 2020-9-13
-	;mov	es, BaseOfBoot 					;modified by mingxuan 2020-9-13
-	;mov	eax, dword [fs:BS_RootClus]		;modified by mingxuan 2020-9-13
-	;mov		eax, dword [BS_RootClus]		;modified by mingxuan 2020-9-17
-	mov		eax,  [BS_RootClus]
-
-	mov		dword [bp - CURRENT_CLUSTER], eax
-
-	;for test, added by mingxuan 2020-9-4
-	;call 	DispStr		;
-	;jmp $ 
-
-_NEXT_ROOT_CLUSTER:
-	; 根据簇号计算扇区号, mingxuan 2020-9-13
-	dec 	eax
-	dec 	eax
-
-	xor		ebx, ebx
-
-	;mov	bl, byte [BPB_SecPerClu]		;deleted by mingxuan 2020-9-13
-	;mov	es, BaseOfBoot 					;modified by mingxuan 2020-9-13
-	;mov	bl, byte [fs:BPB_SecPerClu]		;modified by mingxuan 2020-9-13
-	mov		bl, [BPB_SecPerClu]				;modified by mingxuan 2020-9-17
-
-	;jmp 	$
-
-	mul		ebx
-	
-	;add		eax, DATA_START_SECTOR	;deleted by mingxuan 2020-9-17
-	add		eax, [DATA_START_SECTOR]	;modified by mingxuan 2020-9-17
-	mov		dword [BP - DAP_SECTOR_LOW], eax
-	
-	;mov	dl, [BPB_SecPerClu]				;deleted by mingxuan 2020-9-13
-	;mov	dl, byte [es:BPB_SecPerClu]		;modified by mingxuan 2020-9-13
-	;mov	dl, [fs:BPB_SecPerClu]			;modified by mingxuan 2020-9-15
-	mov		dl, [BPB_SecPerClu]			;modified by mingxuan 2020-9-17
-	;jmp $
-
-
-_NEXT_ROOT_SECTOR:
+;----------------------------------------------------------------------------
+; 函数名: NextCluster
+;----------------------------------------------------------------------------
+; 作用:
+;    获取下一个簇号，buffer段内数据也会修改
+;    eax: 当前簇号，而且返回时eax变为下一个簇号
+NextCluster:
+	pushad
+	push	es
+
+	mov		cx, BaseOfBootBuffer
+	mov		es, cx
+	shl		eax, 2
+	mov		di, ax
+	shr		eax, 9
+	movzx	ecx, word [BPB_RsvdSecCnt]
+	add		eax, ecx
+	mov		cx, 1
+	mov		bx, OffsetOfBootBuffer
 	call	ReadSector
 
-	;for test, added by mingxuan 2020-9-4
-	;call 	DispStr		; 
-	;jmp $
+	and		di, 511
+	mov		eax, [es:di+bx]
+	and		eax, CLUSTER_Mask
 
-	mov		di, DATA_BUF_OFF
-	mov		bl, DIR_PER_SECTOR
+	pop		es
+	mov		bx, sp
+	mov		[bx + 28], eax
 
-_NEXT_ROOT_ENTRY:
-	cmp		byte [di], DIR_NAME_FREE
-	jz		_MISSING_LOADER
+	popad
+	ret
 
-	push 	di;
+Init:
+	; 临时存放设备号
+	mov		[DriverNumber], dl
+	mov		[PartitionLBA], ebx
+	mov		sp, OffsetOfBoot
+
+	; es buffer段基址
+	; di 指向buffer段中当前文件项的地址
+	; eax 当前根目录区簇号
+FindLoaderInit:
+	movzx	ax, byte [BPB_SecPerClus]
+	mul		word [BPB_BytsPerSec]
+	add		ax, OffsetOfBootBuffer
+	mov		[EndOfBuffer], ax
+
+	movzx	eax, byte [BPB_NumFATs]
+	mul		dword [BPB_FATSz32]
+	movzx	edx, word [BPB_RsvdSecCnt]
+	add		eax, edx
+	mov		[SecOfDataZone], eax
+
+	mov		ax, BaseOfBootBuffer
+	mov		es, ax
+	mov		eax, [BPB_RootClus]
+LoadDirCluster:
+	mov		bx, OffsetOfBootBuffer
+	call	ReadCluster
+
+	mov		di, bx
+FindLoader:
+	push	di
+	; 由于DIR_Name为0，就不用再加了
 	mov		si, LoaderName
-	;add	si, BOOT_FAT32_INFO ; added by mingxuan 2020-9-16
-	;mov	si, 0x7df1 			; for test, added by mingxuan 2020-9-16
-	
-	mov		cx, 10
+	mov		ecx, 11
 	repe	cmpsb
-	jcxz	_FOUND_LOADER
+	jz		LoaderFound
+
+	pop		di
+	add		di, SizeOfDIR
+	cmp		di, [EndOfBuffer]
+	jnz		FindLoader
+
+	call	NextCluster
+	cmp		eax, CLUSTER_Last
+	jnz		LoadDirCluster
+
+LoaderNotFound:
+	mov		dh, 1
+	call	DispStr
+	jmp		$
+
+	; es loader段基址
+	; bx loader段偏移
+	; dx 一个簇对应的字节数
+	; eax 当前loader簇号
+LoaderFound:
+	movzx	ax, byte [BPB_SecPerClus]
+	mul		word [BPB_BytsPerSec]
+	mov		dx, ax
 
 	pop		di
-	add		di, DIR_ENTRY_SIZE	
-	dec		bl
-	jnz		_NEXT_ROOT_ENTRY
-
-	dec		dl
-	jz 		_CHECK_NEXT_ROOT_CLUSTER
-
-	inc		dword [bp - DAP_SECTOR_LOW]
-	jmp 	_NEXT_ROOT_SECTOR
-
-; Comments, added by mingxuan 2020-9-10
-;====================================================================
-; 检查是否还有下一个簇(读取FAT表的相关信息)
-;  N = 数据簇号
-;  FAT_BYTES(在FAT表中的偏移)  = N*4  (FAT32)
-;  FAT_SECTOR = FAT_BYTES / BPB_BytesPerSec
-;  FAT_OFFSET = FAT_BYTES % BPB_BytesPerSec
-;====================================================================
-_CHECK_NEXT_ROOT_CLUSTER: ; 检查是否还有下一个簇
-
-	 ; 计算FAT表项所在的簇号和偏移 
-	 ; FatOffset(在FAT表中的偏移) = ClusterNum(簇号) * 4
-	 XOR  	EDX, EDX
-	 MOV  	EAX, DWORD[BP - CURRENT_CLUSTER]
-	 SHL  	EAX, 2 ;FatOffset = ClusterNum * 4
-
-	 XOR  	ECX, ECX
-	 ;MOV  	CX, WORD [ BPB_BytesPerSec ] 	;deleted by mingxuan 2020-9-13
-	 ;mov	es, BaseOfBoot 					;modified by mingxuan 2020-9-13
-	 ;mov	cx, word [fs:BPB_BytesPerSec]	;modified by mingxuan 2020-9-13
-	 mov	cx, word [BPB_BytesPerSec]	;modified by mingxuan 2020-9-17
-	 DIV  	ECX  ; EAX = Sector EDX = OFFSET
-
-	 ; 计算FAT表的起始扇区号
-	 ; added by mingxuan 2020-9-17
-	 ;mov	ebx, dword [ fs:OffsetOfActiPartStartSec ]
-	 ;add	bx, word [ fs:BPB_RsvdSecCnt ]
-
-	 ; 设置缓冲区地址
-	 ;ADD  	EAX, FAT_START_SECTOR ;deleted by mingxuan 2020-9-17
-	 ADD  	EAX, [FAT_START_SECTOR] ;modified by mingxuan 2020-9-17
-	 ;add	eax, ebx			  ;modified by mingxuan 2020-9-17
-	 MOV  	DWORD [ BP - DAP_SECTOR_LOW ], EAX 
-	   
-	 call  ReadSector
-	  
-	 ; 检查下一个簇
-	 MOV  	DI,DX
-	 ADD  	DI,DATA_BUF_OFF
-	 MOV  	EAX, DWORD[DI]  ; EAX = 下一个要读的簇号
-	 AND  	EAX, CLUSTER_MASK
-	 MOV  	DWORD[ BP - CURRENT_CLUSTER ],EAX
-	 CMP  	EAX,CLUSTER_LAST  ; CX >= 0FFFFFF8H，则意味着没有更多的簇了
-
-	 JB  _NEXT_ROOT_CLUSTER
-
-	;for test, added by mingxuan 2020-9-10
-	;call 	DispStr		;    
-
-	 JMP  _MISSING_LOADER
-
-_FOUND_LOADER:
-
-	;for test, added by mingxuan 2020-9-10
-	;call 	DispStr		; 
-	;JMP  	$ ;for test, added by mingxuan 2020-9-10
-
-	 ; 目录结构地址放在DI中
-	 pop  di
-	 xor  eax, eax
-	 mov  ax, [di + OFF_START_CLUSTER_HIGH] ; 起始簇号高32位
-	 shl  ax, 16
-	 mov  ax, [di + OFF_START_CLUSTER_LOW]  ; 起始簇号低32位
-	 mov  dword [ bp - CURRENT_CLUSTER ], eax
-	 mov  cx, OSLOADER_SEG      ; CX  = 缓冲区段地址 
-
-	; 清屏
-	; for test, added by mingxuan 2020-9-15
-	;pusha
-	;mov		dx, 0184fh		; 右下角: (80, 50)
-	;int		10h				; int 10h
-	;popa
-
-
-_NEXT_DATA_CLUSTER:
-	 ; 根据簇号计算扇区号
-	 DEC  EAX
-	 DEC  EAX  
-	 XOR  EBX,EBX 
-	 
-	 ;MOV  BL, BYTE [ BPB_SecPerClu ]	;deleted by mingxuan 2020-9-13
-	 ;mov  es, BaseOfBoot 				;modified by mingxuan 2020-9-13
-	 ;mov  bl, byte [fs:BPB_SecPerClu]	;modified by mingxuan 2020-9-13
-	 mov  bl, [BPB_SecPerClu]	;modified by mingxuan 2020-9-17
-	 
-	 MUL  EBX 
-	 ;ADD  EAX, DATA_START_SECTOR ;deleted by mingxuan 2020-9-17
-	 ADD  EAX, [DATA_START_SECTOR] ;modified by mingxuan 2020-9-17
-	 MOV  DWORD[ BP - DAP_SECTOR_LOW  ], EAX
-	 
-	 ;MOV  BL , BYTE [BPB_SecPerClu]
-	 ;mov  bl, byte [fs:BPB_SecPerClu]	;modified by mingxuan 2020-9-13
-	 mov  bl, byte [BPB_SecPerClu]	;modified by mingxuan 2020-9-17
-
-	 ; 设置缓冲区
-	 MOV  WORD [ BP - DAP_BUFFER_SEG   ], CX
-	 MOV  WORD [ BP - DAP_BUFFER_OFF   ], OSLOADER_SEG_OFF
-
-_NEXT_DATA_SECTOR:
-	 ; 读取簇中的每个扇区(内层循环)
-	 ; 注意 : 通过检查文件大小，可以避免读取最后一个不满簇的所有大小
-	 call  ReadSector
-	 
-	 ; 更新地址，继续读取
-	 ;MOV   AX, WORD [BPB_BytesPerSec] 		;deleted by mingxuan 2020-9-13
-	 ;mov	es, BaseOfBoot 					;modified by mingxuan 2020-9-13
-	 ;mov	ax, word [fs:BPB_BytesPerSec]	;modified by mingxuan 2020-9-13
-	 mov	ax, word [BPB_BytesPerSec]	;modified by mingxuan 2020-9-17
-
-	 ADD  WORD  [BP - DAP_BUFFER_OFF], ax 
-	 INC  DWORD [BP - DAP_SECTOR_LOW]  ; 递增扇区号
-	 DEC  BL        ; 内层循环计数
-
-	 JNZ  _NEXT_DATA_SECTOR
-
-	;for test, added by mingxuan 2020-9-10
-	;call 	DispStr		; 
-	;JMP  	$ ;for test, added by mingxuan 2020-9-10
-
-	  
-	 ; 更新读取下一个簇的缓冲区地址
-	 ;MOV  	CL, BYTE [ BPB_SecPerClu ]
-	 ;mov  	es, BaseOfBoot 				;modified by mingxuan 2020-9-13
-	 ;mov  	cl, byte [fs:BPB_SecPerClu]	;modified by mingxuan 2020-9-13
-	 mov  	cl, [BPB_SecPerClu]			;modified by mingxuan 2020-9-17
-
-	 ;MOV   AX, WORD [BPB_BytesPerSec]		;deleted by mingxuan 2020-9-13
-	 ;mov	es, BaseOfBoot 					;modified by mingxuan 2020-9-13
-	 ;mov	ax, word [fs:BPB_BytesPerSec]	;modified by mingxuan 2020-9-13
-	 mov	ax, [BPB_BytesPerSec]			;modified by mingxuan 2020-9-17
-
-	 SHR  	AX, 4
-	 MUL  	CL
-	 ADD  	AX, WORD [ BP - DAP_BUFFER_SEG ] 
-	 MOV  	CX, AX ; 保存下一个簇的缓冲区段地址
-	 
-	 ;====================================================================
-	 ; 检查是否还有下一个簇(读取FAT表的相关信息)
-	 ;  LET   N = 数据簇号
-	 ;  THUS FAT_BYTES  = N*4  (FAT32)
-	 ;  FAT_SECTOR = FAT_BYTES / BPB_BytesPerSec
-	 ;  FAT_OFFSET = FAT_BYTES % BPB_BytesPerSec
-	 ;====================================================================
-	 
-	 ; 计算FAT所在的簇号和偏移 
-	 MOV  EAX,DWORD [BP - CURRENT_CLUSTER]
-	 XOR  EDX,EDX
-	 SHL  EAX,2
-	 XOR  EBX,EBX
-
-	 ;MOV  BX,WORD [ BPB_BytesPerSec ]		;deleted by mingxuan 2020-9-13
-	 ;mov	es, BaseOfBoot 					;modified by mingxuan 2020-9-13
-	; mov	bx, word [fs:BPB_BytesPerSec]	;modified by mingxuan 2020-9-13
-	 mov	bx, [BPB_BytesPerSec]			;modified by mingxuan 2020-9-17
-
-	 DIV  	EBX   ; EAX = Sector  EDX = Offset
-	 
-	 ; 计算FAT表的起始扇区号
-	 ; added by mingxuan 2020-9-17
-	 ;mov	ebx, dword [ fs:OffsetOfActiPartStartSec ]
-	 ;add	bx, word [ fs:BPB_RsvdSecCnt ]
-
-	 ; 设置int 13h读取的绝对扇区号
-	 ;ADD  EAX, FAT_START_SECTOR ;deleted by mingxuan 2020-9-17
-	 ADD  EAX, [FAT_START_SECTOR] ;modified by mingxuan 2020-9-17
-	 ;add  eax, ebx	;modified by mingxuan 2020-9-17
-	 MOV  DWORD [ BP - DAP_SECTOR_LOW ], EAX
-
-	 ; 设置int 13h写入内存的缓冲区地址 
-	 MOV  WORD [BP - DAP_BUFFER_SEG  ], 01000H 
-	 MOV  WORD [BP - DAP_BUFFER_OFF  ], DATA_BUF_OFF
-
-	 ; 读取扇区 ; 把FAT表读进内存
-	 CALL  ReadSector
-	  
-	 ; 检查下一个簇
-	 MOV  DI,DX
-	 ADD  DI,DATA_BUF_OFF
-	 MOV  EAX,DWORD[DI]  ; EAX = 下一个要读的簇号
-	 AND  EAX,CLUSTER_MASK
-	 MOV  DWORD[ BP - CURRENT_CLUSTER ],EAX
-	 CMP  EAX,CLUSTER_LAST  ; CX >= 0FFFFFF8H，则意味着没有更多的簇了
-
-	;for test, added by mingxuan 2020-9-10
-	;call 	DispStr		; 
-	;JMP  	$ ;for test, added by mingxuan 2020-9-10
-
-	; 清屏
-	; for test, added by mingxuan 2020-9-15
-	;pusha
-	;mov		dx, 0184fh		; 右下角: (80, 50)
-	;int		10h				; int 10h
-	;popa
-
-
-	 JB  _NEXT_DATA_CLUSTER
-
-_RUN_LOADER: 
-
-	;mov  	dl, [BS_DriveNum]			;deleted by mingxuan 2020-9-13
-	;mov		es, BaseOfBoot 				;modified by mingxuan 2020-9-13
-	;mov		dl, [fs:BS_DriveNum]		;modified by mingxuan 2020-9-13
-	mov		dl, [BS_DriveNum]		;modified by mingxuan 2020-9-17
-
-	;for test, added by mingxuan 2020-9-10
-	;call	DispStr		; 
-	;jmp $ ;for test 2020-9-10, mingxuan
-
-	; 清屏
-	; for test, added by mingxuan 2020-9-15
-	;pusha
-	;mov		dx, 0184fh		; 右下角: (80, 50)
-	;int		10h				; int 10h
-	;popa
-
-
-	jmp  OSLOADER_SEG : OSLOADER_SEG_OFF
-
-
-LoaderName     db "LOADER  BIN"       ; 第二阶段启动程序 FDOSLDR.BIN
-
-; for display
-; added by mingxuan 2020-9-4
-;TestMessage:		db	"#"	; 27字节, 不够则用空格补齐. 序号 0
-
-; for display
-; added by mingxuan 2020-9-4
-;DispStr:
-;	pusha
-
-;	mov		ax, TestMessage
-;	mov		bp, ax
-;	mov		cx, 1
-;	mov		ax, 01301h		; AH = 13,  AL = 01h
-;	mov		bx, 0007h		; 页号为0(BH = 0) 黑底白字(BL = 07h)
-
-;	int		10h			; int 10h
-
-;	popa
-	
-;	ret
-
-
-times 	510-($-$$)	db	0	; 填充剩下的空间，使生成的二进制代码恰好为512字节
-dw 	0xaa55				; 结束标志
+	mov		ax, [es:di + DIR_FstClusHI]
+	shl		eax, 8
+	mov		ax, [es:di + DIR_FstClusLO]
+
+	mov		cx, BaseOfLoader
+	mov		es, cx
+	mov		bx, OffsetOfLoader
+	movzx	cx, byte [BPB_SecPerClus]
+LoadLoader:
+	call	ReadCluster
+	add		bx, dx
+	call	NextCluster
+	cmp		eax, CLUSTER_Last
+	jnz		LoadLoader
+
+	mov		dl, [DriverNumber]
+	mov		ebx, [PartitionLBA]
+	jmp		BaseOfLoader:OffsetOfLoader
+
+times SizeOfBoot-($-$$) db 0
diff --git a/boot/include/boot.inc b/boot/include/boot.inc
new file mode 100644
index 0000000..0c50990
--- /dev/null
+++ b/boot/include/boot.inc
@@ -0,0 +1,6 @@
+BaseOfBoot			equ 0000h
+OffsetOfBoot		equ 7c00h
+BaseOfBootBuffer	equ BaseOfBoot
+OffsetOfBootBuffer	equ 7e00h
+
+SizeOfBoot			equ 512 - 2 - 90
diff --git a/boot/include/fat32.inc b/boot/include/fat32.inc
index 03b4245..033192c 100644
--- a/boot/include/fat32.inc
+++ b/boot/include/fat32.inc
@@ -1,61 +1,49 @@
-	;deleted by mingxuan 2020-9-16
-	;BS_OEM			DB	'mkfs.fat'
-	;BPB_BytesPerSec	DW	0x200
-	;BPB_SecPerClu 	DB	1
-	;BPB_RsvdSecCnt	DW	0x20
-	;BPB_NumFATs		DB	2
-	;BPB_RootEntCnt	DW 	0
-	;BPB_TotSec16	DW	0
-	;BPB_Media		DB 	0xf8
-	;BPB_FATSz16		DW	0
-	;BPB_SecPerTrk	DW	0x20
-	;BPB_NumHeads	DW	0x40
-	;BPB_HiddSec		DD	0
-	;BPB_TotSec32	DD	0x015791
-	;BS_SecPerFAT	DD	0x02a5
-	;BS_Flag			DW	0
-	;BS_Version		DW	0
-	;BS_RootClus		DD	2
-	;BS_FsInfoSec 	DW	1
-	;BS_BackBootSec 	DW	6
-	;BS_Unuse1		DD	0
-	;BS_Unuse2		DD	0
-	;BS_Unuse3		DD 	0
-	;BS_DriveNum		DB	0x80
-	;BS_Unuse4		DB	0
-	;BS_ExtBootFlag	DB	0x29
-	;BS_VolNum		DD	0xbe3a8ff5
-	;BS_VolName		DB	'MZY hd boot'
+; [in]: OffsetOfBPB
+BS_jmpBoot		equ	OffsetOfBPB + 0
+BS_OEMName		equ	OffsetOfBPB + 3
+BPB_BytsPerSec	equ	OffsetOfBPB + 11
+BPB_SecPerClus	equ	OffsetOfBPB + 13
+BPB_RsvdSecCnt	equ	OffsetOfBPB + 14
+BPB_NumFATs		equ	OffsetOfBPB + 16
+BPB_RootEntCnt	equ 	OffsetOfBPB + 17
+BPB_TotSec16	equ	OffsetOfBPB + 19
+BPB_Media		equ 	OffsetOfBPB + 21
+BPB_FATSz16		equ	OffsetOfBPB + 22
+BPB_SecPerTrk	equ	OffsetOfBPB + 24
+BPB_NumHeads	equ	OffsetOfBPB + 26
+BPB_HiddSec		equ	OffsetOfBPB + 28
+BPB_TotSec32	equ	OffsetOfBPB + 32
+BPB_FATSz32		equ	OffsetOfBPB + 36
+BPB_ExtFlags	equ	OffsetOfBPB + 40
+BPB_FSVer		equ	OffsetOfBPB + 42
+BPB_RootClus	equ	OffsetOfBPB + 44
+BPB_FSInfo		equ	OffsetOfBPB + 48
+BPB_BkBootSec	equ	OffsetOfBPB + 50
+BPB_Reserved	equ	OffsetOfBPB + 52
+BS_DrvNum		equ	OffsetOfBPB + 64
+BS_Reserved1	equ	OffsetOfBPB + 65
+BS_BootSig		equ	OffsetOfBPB + 66
+BS_VolID		equ	OffsetOfBPB + 67
+BS_VolLab		equ	OffsetOfBPB + 71
+BS_FilSysType	equ	OffsetOfBPB + 82
+EndOfBPB		equ	OffsetOfBPB + 90
 
-; added by mingxuan 2020-9-12
-;BaseOfBoot 			equ	1000h 		; added by mingxuan 2020-9-12
-;OffsetOfBoot		equ	7c00h		; load Boot sector to BaseOfBoot:OffsetOfBoot
-
-BPB_BytesPerSec	    equ		(OffsetOfBoot + 0xb)	;每扇区字节数
-BPB_SecPerClu 		equ		(OffsetOfBoot + 0xd)	;每簇扇区数 
-BPB_RsvdSecCnt		equ		(OffsetOfBoot + 0xe)	;保留扇区数
-BPB_NumFATs			equ		(OffsetOfBoot + 0x10)	;FAT表数
-BPB_RootEntCnt		equ 	(OffsetOfBoot + 0x11)	;FAT32不使用
-BPB_TotSec16		equ		(OffsetOfBoot + 0x13)	;扇区总数
-BPB_Media			equ 	(OffsetOfBoot + 0x15)	;介质描述符
-BPB_FATSz16			equ		(OffsetOfBoot + 0x16)	;每个FAT表的大小扇区数(FAT32不使用)
-BPB_SecPerTrk		equ		(OffsetOfBoot + 0x18)	;每磁道扇区数
-BPB_NumHeads		equ		(OffsetOfBoot + 0x1a)	;磁头数
-BPB_HiddSec			equ	    (OffsetOfBoot + 0x1c)	;分区已使用扇区数
-BPB_TotSec32		equ		(OffsetOfBoot + 0x20)	;文件系统大小扇区数
-	
-BS_SecPerFAT		equ		(OffsetOfBoot + 0x24)	;每个FAT表大小扇区数
-BS_Flag				equ		(OffsetOfBoot + 0x28)	;标记
-BS_Version			equ		(OffsetOfBoot + 0x2a)	;版本号
-BS_RootClus			equ		(OffsetOfBoot + 0x2c)	;根目录簇号
-BS_FsInfoSec 		equ		(OffsetOfBoot + 0x30)	;FSINFO扇区号
-BS_BackBootSec 		equ	    (OffsetOfBoot + 0x32)	;备份引导扇区位置
-BS_Unuse1			equ		(OffsetOfBoot + 0x34)	;未使用
-;BS_Unuse2			equ		(OffsetOfBoot + 0x40)	;未使用	;deleted by mingxuan 2020-9-15
-;BS_Unuse3			equ 	(OffsetOfBoot + 0x41)	;未使用	;deleted by mingxuan 2020-9-15
-BS_DriveNum			equ		(OffsetOfBoot + 0x40)	;设备号
-BS_Unuse4			equ		(OffsetOfBoot + 0x41)	;未使用
-BS_ExtBootFlag		equ		(OffsetOfBoot + 0x42)	;扩展引导标志
-BS_VolNum			equ		(OffsetOfBoot + 0x43)	;卷序列号
-BS_VolName			equ		(OffsetOfBoot + 0x47)	;卷标
+DIR_Name			equ	0
+DIR_Attr			equ	11
+DIR_NTRes			equ	12
+DIR_CrtTimeTenth	equ	13
+DIR_CrtTime			equ	14
+DIR_CrtDate			equ	16
+DIR_LstAccDate		equ	18
+DIR_FstClusHI		equ	20
+DIR_WrtTime			equ	22
+DIR_WrtDate			equ	24
+DIR_FstClusLO		equ	26
+DIR_FileSize		equ	28
+SizeOfDIR			equ	32
 
+CLUSTER_Free	equ	00000000h
+CLUSTER_Base	equ	00000002h
+CLUSTER_Bad		equ	0FFFFFF7h
+CLUSTER_Last	equ	0FFFFFFFh
+CLUSTER_Mask	equ	0FFFFFFFh
diff --git a/boot/include/lib.inc b/boot/include/lib.inc
deleted file mode 100644
index 1faceea..0000000
--- a/boot/include/lib.inc
+++ /dev/null
@@ -1,170 +0,0 @@
-
-; ------------------------------------------------------------------------
-; 显示 AL 中的数字
-; ------------------------------------------------------------------------
-DispAL:
-	push	ecx
-	push	edx
-	push	edi
-
-	mov	edi, [dwDispPos]
-
-	mov	ah, 0Fh			; 0000b: 黑底    1111b: 白字
-	mov	dl, al
-	shr	al, 4
-	mov	ecx, 2
-.begin:
-	and	al, 01111b
-	cmp	al, 9
-	ja	.1
-	add	al, '0'
-	jmp	.2
-.1:
-	sub	al, 0Ah
-	add	al, 'A'
-.2:
-	mov	[gs:edi], ax
-	add	edi, 2
-
-	mov	al, dl
-	loop	.begin
-	;add	edi, 2
-
-	mov	[dwDispPos], edi
-
-	pop	edi
-	pop	edx
-	pop	ecx
-
-	ret
-; DispAL 结束-------------------------------------------------------------
-
-
-; ------------------------------------------------------------------------
-; 显示一个整形数
-; ------------------------------------------------------------------------
-DispInt:
-	mov	eax, [esp + 4]
-	shr	eax, 24
-	call	DispAL
-
-	mov	eax, [esp + 4]
-	shr	eax, 16
-	call	DispAL
-
-	mov	eax, [esp + 4]
-	shr	eax, 8
-	call	DispAL
-
-	mov	eax, [esp + 4]
-	call	DispAL
-
-	mov	ah, 07h			; 0000b: 黑底    0111b: 灰字
-	mov	al, 'h'
-	push	edi
-	mov	edi, [dwDispPos]
-	mov	[gs:edi], ax
-	add	edi, 4
-	mov	[dwDispPos], edi
-	pop	edi
-
-	ret
-; DispInt 结束------------------------------------------------------------
-
-; ------------------------------------------------------------------------
-; 显示一个字符串
-; ------------------------------------------------------------------------
-DispStr:
-	push	ebp
-	mov	ebp, esp
-	push	ebx
-	push	esi
-	push	edi
-
-	mov	esi, [ebp + 8]	; pszInfo
-	mov	edi, [dwDispPos]
-	mov	ah, 0Fh
-.1:
-	lodsb
-	test	al, al
-	jz	.2
-	cmp	al, 0Ah	; 是回车吗?
-	jnz	.3
-	push	eax
-	mov	eax, edi
-	mov	bl, 160
-	div	bl
-	and	eax, 0FFh
-	inc	eax
-	mov	bl, 160
-	mul	bl
-	mov	edi, eax
-	pop	eax
-	jmp	.1
-.3:
-	mov	[gs:edi], ax
-	add	edi, 2
-	jmp	.1
-
-.2:
-	mov	[dwDispPos], edi
-
-	pop	edi
-	pop	esi
-	pop	ebx
-	pop	ebp
-	ret
-; DispStr 结束------------------------------------------------------------
-
-; ------------------------------------------------------------------------
-; 换行
-; ------------------------------------------------------------------------
-DispReturn:
-	push	szReturn
-	call	DispStr			;printf("\n");
-	add	esp, 4
-
-	ret
-; DispReturn 结束---------------------------------------------------------
-
-
-; ------------------------------------------------------------------------
-; 内存拷贝，仿 memcpy
-; ------------------------------------------------------------------------
-; void* MemCpy(void* es:pDest, void* ds:pSrc, int iSize);
-; ------------------------------------------------------------------------
-MemCpy:
-	push	ebp
-	mov	ebp, esp
-
-	push	esi
-	push	edi
-	push	ecx
-
-	mov	edi, [ebp + 8]	; Destination
-	mov	esi, [ebp + 12]	; Source
-	mov	ecx, [ebp + 16]	; Counter
-.1:
-	cmp	ecx, 0		; 判断计数器
-	jz	.2		; 计数器为零时跳出
-
-	mov	al, [ds:esi]		; ┓
-	inc	esi			; ┃
-					; ┣ 逐字节移动
-	mov	byte [es:edi], al	; ┃
-	inc	edi			; ┛
-
-	dec	ecx		; 计数器减一
-	jmp	.1		; 循环
-.2:
-	mov	eax, [ebp + 8]	; 返回值
-
-	pop	ecx
-	pop	edi
-	pop	esi
-	mov	esp, ebp
-	pop	ebp
-
-	ret			; 函数结束，返回
-; MemCpy 结束-------------------------------------------------------------
-
diff --git a/boot/include/loader.inc b/boot/include/loader.inc
index 24777c7..8fa468b 100644
--- a/boot/include/loader.inc
+++ b/boot/include/loader.inc
@@ -1,69 +1,14 @@
-; this is generated by build tools, defines KernelEntryPointPhyAddr as entry address of kernel
-%include "kernel_entry.inc"
+BaseOfLoader		equ 1000h
+OffsetOfLoader		equ 0000h
+BaseOfLoaderPhyAddr	equ BaseOfLoader * 10h + OffsetOfLoader
 
-;==============================================================================================================================
-BaseOfStack		equ 	0x0100
-STACK_ADDR		equ		0x0ea
-SEG_ADDR		equ		0x09000
-DATA_BUF_OFF	equ 	0x09000
+BaseOfDeviceInfo	equ 9000h
+OffsetOfVideoCard	equ 00h
+OffsetOfVGAInfo		equ 04h
+OffsetOfARDSCount	equ 0ah
+OffsetOfARDSBuffer	equ 0eh
 
-BaseOfBoot 					equ	1000h 		; added by mingxuan 2020-9-17
-OffsetOfBoot				equ	7c00h		; load Boot sector to BaseOfBoot:OffsetOfBoot
-OffsetOfActiPartStartSec	equ 7e00h		; 活动分区的起始扇区号相对于BaseOfBoot的偏移量	;added by mingxuan 2020-9-17
-											; 该变量来自分区表，保存在该内存地址，用于在os_boot和loader中查找FAT32文件
+StackTopInProtect	equ	BaseOfLoaderPhyAddr
 
-;FAT_START_SECTOR 	equ  	0x820	  	; FAT表的起始扇区号  DWORD
-;FAT_START_SECTOR 	equ  	0x1020	  	; FAT表的起始扇区号  DWORD ; for test 2020-9-12, mingxuan
-;DATA_START_SECTOR 	equ  	0xd6a	  	; 数据区起始扇区号  DWORD
-;DATA_START_SECTOR 	equ  	0x156a	  	; 数据区起始扇区号  DWORD ; for test 2020-9-12, mingxuan
-;DATA_START_SECTOR 	equ  	0x13a4	  	; 数据区起始扇区号  DWORD ; for test 2020-9-16, mingxuan
-
-DIR_PER_SECTOR  	equ  	0x10  		; 每个扇区所容纳的目录 BYTE
-
-; 扩展磁盘服务所使用的地址包
-DAP_SECTOR_HIGH  	equ  	4  		; 起始扇区号的高32位 ( 每次调用需要重置 ) DWORD
-DAP_SECTOR_LOW  	equ  	8  		; 起始扇区号的低32位 ( 每次调用需要重置 ) DWORD
-DAP_BUFFER_SEG  	equ  	10  		; 缓冲区段地址   ( 每次调用需要重置 ) WORD
-DAP_BUFFER_OFF  	equ  	12  		; 缓冲区偏移   ( 每次调用需要重置 ) WORD
-DAP_RESERVED2  		equ  	13  		; 保留字节
-DAP_READ_SECTORS 	equ  	14  		; 要处理的扇区数(1 - 127 )
-DAP_RESERVED1  		equ  	15  		; 保留字节
-DAP_PACKET_SIZE  	equ  	16  		; 包的大小为16字节
-
-CURRENT_CLUSTER  	equ  	20  		; 当前正在处理的簇号 DWORD
-
-; 目录项结构
-OFF_START_CLUSTER_HIGH  equ  	20  		; 起始簇号高位  WORD
-OFF_START_CLUSTER_LOW  	equ  	26  		; 起始簇号低位  WORD
-
-; 相关常量
-DIR_NAME_FREE    	equ  	0x00  		; 该项是空闲的
-DIR_ENTRY_SIZE    	equ  	32  		; 每个目录项的尺寸
-
-; 簇属性
-CLUSTER_MASK    	equ  	0FFFFFFFH 	; 簇号掩码
-CLUSTER_LAST    	equ  	0FFFFFF8H   	;0xFFFFFFF8-0xFFFFFFFF表示文件的最后一个簇
-
-BaseOfLoader		equ	 09000h	; LOADER.BIN 被加载到的位置 ----  段地址
-OffsetOfLoader		equ	  0100h	; LOADER.BIN 被加载到的位置 ---- 偏移地址
-
-BaseOfLoaderPhyAddr	equ	BaseOfLoader * 10h	; LOADER.BIN 被加载到的位置 ---- 物理地址 (= BaseOfLoader * 10h)
-
-BaseOfKernelFile	equ	 07000h	; KERNEL.BIN 被加载到的位置 ----  段地址
-OffsetOfKernelFile	equ	     0h	; KERNEL.BIN 被加载到的位置 ---- 偏移地址
-
-BaseOfKernelFilePhyAddr	equ	BaseOfKernelFile * 10h
-
-BaseOfEchoFile	equ		  07E0h	; KERNEL.BIN 被加载到的位置 ----  段地址
-OffsetOfEchoFile	equ	     0h	; KERNEL.BIN 被加载到的位置 ---- 偏移地址
-
-BaseOfEchoFilePhyAddr	equ	BaseOfKernelFile * 10h
-
-PageDirBase		equ	200000h	; 页目录开始地址:		2M
-PageTblBase		equ	201000h	; 页表开始地址:			2M + 4K
-
-PageTblNumAddr		equ 500h;页表数量放在这个位置	delete by visual 2016.4.28
-
-FMIBuff			equ	007ff000h
-
-;==============================================================================================================================
+SelectorFlatC	equ 0x08
+SelectorFlatRW	equ 0x10
diff --git a/boot/include/mbr.inc b/boot/include/mbr.inc
new file mode 100644
index 0000000..17b3350
--- /dev/null
+++ b/boot/include/mbr.inc
@@ -0,0 +1,14 @@
+BaseOfMBR			equ 0000h
+OffsetOfMBR			equ 7000h
+StartOfMBRTable		equ 1beh
+EndOfMBRTable		equ 1feh
+
+MBRPartitionState		equ 00h
+MBRFirstCHSAddress		equ 01h
+MBRPartitionType		equ 04h
+MBRLastCHSAddress		equ 05h
+MBRFirstLBA				equ 08h
+MBRSectorNumber			equ 0ch
+MBRPartitionEntrySize	equ 10h
+
+SizeOfMBR			equ StartOfMBRTable
diff --git a/boot/include/packet.inc b/boot/include/packet.inc
new file mode 100644
index 0000000..356a69b
--- /dev/null
+++ b/boot/include/packet.inc
@@ -0,0 +1,6 @@
+Packet_BufferPacketSize	equ	0
+Packet_Sectors			equ	2
+Packet_BufferOffset		equ	4
+Packet_BufferSegment	equ	6
+Packet_StartSectors		equ	8
+SizeOfPacket			equ	16
diff --git a/boot/include/pm.inc b/boot/include/pm.inc
index 6d4c94c..108ffeb 100644
--- a/boot/include/pm.inc
+++ b/boot/include/pm.inc
@@ -107,38 +107,38 @@
 ;		P=1 表示描述符对地址转换是有效的，或者说该描述符所描述的段存在，即在内存中；
 ;		P=0 表示描述符对地址转换无效，即该段不存在。使用该描述符进行内存访问时会引起异常。
 ;
-; (2) DPL:  表示描述符特权级(Descriptor Privilege level)，共2位。它规定了所描述段的特权级，用于特权检查，以决定对该段能否访问。 
+; (2) DPL:  表示描述符特权级(Descriptor Privilege level)，共2位。它规定了所描述段的特权级，用于特权检查，以决定对该段能否访问。
 ;
 ; (3) S:   说明描述符的类型。
-;		对于存储段描述符而言，S=1，以区别与系统段描述符和门描述符(S=0)。 
+;		对于存储段描述符而言，S=1，以区别与系统段描述符和门描述符(S=0)。
 ;
 ; (4) TYPE: 说明存储段描述符所描述的存储段的具体属性。
 ;
-;		 
+;
 ;	数据段类型	类型值		说明
 ;			----------------------------------
-;			0		只读 
-;			1		只读、已访问 
-;			2		读/写 
-;			3		读/写、已访问 
-;			4		只读、向下扩展 
-;			5		只读、向下扩展、已访问 
-;			6		读/写、向下扩展 
-;			7		读/写、向下扩展、已访问 
+;			0		只读
+;			1		只读、已访问
+;			2		读/写
+;			3		读/写、已访问
+;			4		只读、向下扩展
+;			5		只读、向下扩展、已访问
+;			6		读/写、向下扩展
+;			7		读/写、向下扩展、已访问
+;
 ;
-;		
 ;			类型值		说明
 ;	代码段类型	----------------------------------
-;			8		只执行 
-;			9		只执行、已访问 
-;			A		执行/读 
-;			B		执行/读、已访问 
-;			C		只执行、一致码段 
-;			D		只执行、一致码段、已访问 
-;			E		执行/读、一致码段 
-;			F		执行/读、一致码段、已访问 
+;			8		只执行
+;			9		只执行、已访问
+;			A		执行/读
+;			B		执行/读、已访问
+;			C		只执行、一致码段
+;			D		只执行、一致码段、已访问
+;			E		执行/读、一致码段
+;			F		执行/读、一致码段、已访问
+;
 ;
-;		
 ;	系统段类型	类型编码	说明
 ;			----------------------------------
 ;			0		<未定义>
@@ -161,20 +161,20 @@
 ; (5) G:    段界限粒度(Granularity)位。
 ;		G=0 表示界限粒度为字节；
 ;		G=1 表示界限粒度为4K 字节。
-;           注意，界限粒度只对段界限有效，对段基地址无效，段基地址总是以字节为单位。 
+;           注意，界限粒度只对段界限有效，对段基地址无效，段基地址总是以字节为单位。
 ;
-; (6) D:    D位是一个很特殊的位，在描述可执行段、向下扩展数据段或由SS寄存器寻址的段(通常是堆栈段)的三种描述符中的意义各不相同。 
+; (6) D:    D位是一个很特殊的位，在描述可执行段、向下扩展数据段或由SS寄存器寻址的段(通常是堆栈段)的三种描述符中的意义各不相同。
 ;           ⑴ 在描述可执行段的描述符中，D位决定了指令使用的地址及操作数所默认的大小。
 ;		① D=1表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段；
-;		② D=0 表示默认情况下，使用16位地址及16位或8位操作数，这样的代码段也称为16位代码段，它与80286兼容。可以使用地址大小前缀和操作数大小前缀分别改变默认的地址或操作数的大小。 
+;		② D=0 表示默认情况下，使用16位地址及16位或8位操作数，这样的代码段也称为16位代码段，它与80286兼容。可以使用地址大小前缀和操作数大小前缀分别改变默认的地址或操作数的大小。
 ;           ⑵ 在向下扩展数据段的描述符中，D位决定段的上部边界。
 ;		① D=1表示段的上部界限为4G；
-;		② D=0表示段的上部界限为64K，这是为了与80286兼容。 
+;		② D=0表示段的上部界限为64K，这是为了与80286兼容。
 ;           ⑶ 在描述由SS寄存器寻址的段描述符中，D位决定隐式的堆栈访问指令(如PUSH和POP指令)使用何种堆栈指针寄存器。
 ;		① D=1表示使用32位堆栈指针寄存器ESP；
-;		② D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。 
+;		② D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。
 ;
-; (7) AVL:  软件可利用位。80386对该位的使用未左规定，Intel公司也保证今后开发生产的处理器只要与80386兼容，就不会对该位的使用做任何定义或规定。 
+; (7) AVL:  软件可利用位。80386对该位的使用未左规定，Intel公司也保证今后开发生产的处理器只要与80386兼容，就不会对该位的使用做任何定义或规定。
 ;
 
 
@@ -296,11 +296,11 @@ PG_USU		EQU	4	; U/S 属性位值, 用户级
 ;        Limit: dd (low 20 bits available)
 ;        Attr:  dw (lower 4 bits of higher byte are always 0)
 %macro Descriptor 3
-	dw	%2 & 0FFFFh				; 段界限 1				(2 字节)
-	dw	%1 & 0FFFFh				; 段基址 1				(2 字节)
-	db	(%1 >> 16) & 0FFh			; 段基址 2				(1 字节)
+	dw	%2 & 0FFFFh							; 段界限 1				(2 字节)
+	dw	%1 & 0FFFFh							; 段基址 1				(2 字节)
+	db	(%1 >> 16) & 0FFh					; 段基址 2				(1 字节)
 	dw	((%2 >> 8) & 0F00h) | (%3 & 0F0FFh)	; 属性 1 + 段界限 2 + 属性 2		(2 字节)
-	db	(%1 >> 24) & 0FFh			; 段基址 3				(1 字节)
+	db	(%1 >> 24) & 0FFh					; 段基址 3				(1 字节)
 %endmacro ; 共 8 字节
 ;
 ; 门
@@ -310,9 +310,9 @@ PG_USU		EQU	4	; U/S 属性位值, 用户级
 ;        DCount:    db
 ;        Attr:      db
 %macro Gate 4
-	dw	(%2 & 0FFFFh)				; 偏移 1				(2 字节)
-	dw	%1					; 选择子				(2 字节)
+	dw	(%2 & 0FFFFh)						; 偏移 1				(2 字节)
+	dw	%1									; 选择子				(2 字节)
 	dw	(%3 & 1Fh) | ((%4 << 8) & 0FF00h)	; 属性					(2 字节)
-	dw	((%2 >> 16) & 0FFFFh)			; 偏移 2				(2 字节)
+	dw	((%2 >> 16) & 0FFFFh)				; 偏移 2				(2 字节)
 %endmacro ; 共 8 字节
 ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
diff --git a/boot/loader.asm b/boot/loader.asm
deleted file mode 100644
index 9d4290e..0000000
--- a/boot/loader.asm
+++ /dev/null
@@ -1,1014 +0,0 @@
-
-; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-;                               loader.asm
-; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-;                                                     Forrest Yu, 2005
-; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-org  0100h
-
-	jmp	LABEL_START		; Start
-
-; 下面是 FAT12 磁盘的头, 之所以包含它是因为下面用到了磁盘的一些信息
-%include	"fat32.inc"
-%include	"loader.inc"
-%include	"pm.inc"
-
-
-; GDT ------------------------------------------------------------------------------------------------------------------------------------------------------------
-;                                                段基址            段界限     , 属性
-LABEL_GDT:				Descriptor             0,                    0, 0						; 空描述符
-LABEL_DESC_FLAT_C:		Descriptor             0,              0fffffh, DA_CR  | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
-LABEL_DESC_FLAT_RW:		Descriptor             0,              0fffffh, DA_DRW | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
-LABEL_DESC_VIDEO:		Descriptor		 0B8000h,               0ffffh, DA_DRW | DA_DPL3	; 显存首地址
-; GDT ------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-GdtLen		equ	$ - LABEL_GDT
-GdtPtr		dw	GdtLen - 1							; 段界限
-			dd	BaseOfLoaderPhyAddr + LABEL_GDT		; 基地址
-
-; GDT 选择子 ----------------------------------------------------------------------------------
-SelectorFlatC		equ	LABEL_DESC_FLAT_C	- LABEL_GDT
-SelectorFlatRW		equ	LABEL_DESC_FLAT_RW	- LABEL_GDT
-SelectorVideo		equ	LABEL_DESC_VIDEO	- LABEL_GDT + SA_RPL3
-; GDT 选择子 ----------------------------------------------------------------------------------
-
-FAT_START_SECTOR 	DD 	0 ;FAT表的起始扇区号 ;added by mingxuan 2020-9-17
-DATA_START_SECTOR 	DD  0 ;数据区起始扇区号 ;added by mingxuan 2020-9-17
-
-LABEL_START:			; <--- 从这里开始 *************
-
-	;for test
-	;added by mingxuan 2020-9-11
-	; 清屏
-	;mov		ax, 0600h		; AH = 6,  AL = 0h
-	;mov		bx, 0700h		; 黑底白字(BL = 07h)
-	;mov		cx, 0			; 左上角: (0, 0)
-	;mov		dx, 0184fh		; 右下角: (80, 50)
-	;int		10h				; int 10h
-
-	;for test
-	;added by mingxuan 2020-9-11
-	;mov		dh, 1
-	;call 	DispStrRealMode
-	;jmp 	$
-
-	cld
-	mov		ax, cs
-	mov		ds, ax
-	mov		es, ax	;deleted by mingxuan 2020-9-16
-	mov		ss, ax
-
-	;added by mingxuan 2020-9-16
-	mov		ax, BaseOfBoot
-	mov		fs, ax 			;fs存储BaseOfBoot，用于查找FAT32的配置信息
-
-	; 计算FAT表的起始扇区号 ; added by mingxuan 2020-9-17
-	mov		eax, [ fs:OffsetOfActiPartStartSec]
-	add		ax, [ fs:BPB_RsvdSecCnt ]
-	mov 	[FAT_START_SECTOR], eax
-
-	; 计算数据区起始扇区号 ; added by mingxuan 2020-9-17
-	add		eax, [ fs:BS_SecPerFAT ]
-	add		eax, [ fs:BS_SecPerFAT ]
-	mov		[DATA_START_SECTOR], eax
-
-	mov		sp, STACK_ADDR
-	mov		bp, BaseOfStack
-
-	mov 	dword [bp - DAP_SECTOR_HIGH ],	00h
-	mov 	byte  [bp - DAP_RESERVED1   ], 	00h
-	mov 	byte  [bp - DAP_RESERVED2   ], 	00h
-	mov 	byte  [bp - DAP_PACKET_SIZE ], 	10h
-	mov		byte  [bp - DAP_READ_SECTORS],  01h
-	mov		word  [bp - DAP_BUFFER_SEG  ],	0x09000
-
-	; 得到内存数
-	mov	ebx, 0			; ebx = 后续值, 开始时需为 0
-	mov	di, _MemChkBuf		; es:di 指向一个地址范围描述符结构（Address Range Descriptor Structure）
-.MemChkLoop:
-	mov	eax, 0E820h		; eax = 0000E820h
-	mov	ecx, 20			; ecx = 地址范围描述符结构的大小
-	mov	edx, 0534D4150h		; edx = 'SMAP'
-	int	15h			; int 15h
-	jc	.MemChkFail
-	add	di, 20
-	inc	dword [_dwMCRNumber]	; dwMCRNumber = ARDS 的个数
-	cmp	ebx, 0
-	jne	.MemChkLoop
-	jmp	.MemChkOK
-.MemChkFail:
-	mov	dword [_dwMCRNumber], 0
-.MemChkOK:
-
-	;jmp	_SEARCH_LOADER	;deleted by mingxuan 2020-9-16
-	jmp		_SEARCH_KERNEL	;modified by mingxuan 2020-9-16
-
-;_MISSING_LOADER: 	;deleted by mingxuan 2020-9-16
-_MISSING_KERNEL:	;modified by mingxuan 2020-9-16
-_DISK_ERROR:
-	;for test
-	;added by mingxuan 2020-9-16
-	; 清屏
-	;mov		ax, 0600h		; AH = 6,  AL = 0h
-	;mov		bx, 0700h		; 黑底白字(BL = 07h)
-	;mov		cx, 0			; 左上角: (0, 0)
-	;mov		dx, 0184fh		; 右下角: (80, 50)
-	;int		10h				; int 10h
-
-	jmp	$
-
-ReadSector:
-	pusha
-	mov		ah, 42h
-	lea 	si, [BP - DAP_PACKET_SIZE]
-
-	;mov	dl, [BS_DriveNum]	;deleted by mingxuan 2020-9-16
-	mov		dl, [fs:BS_DriveNum];modified by mingxuan 2020-9-16
-
-	int 	13h
-	jc 		_DISK_ERROR
-	popa
-	ret
-
-;_SEARCH_LOADER:	;deleted by mingxuan 2020-9-16
-_SEARCH_KERNEL:		;modified by mingxuan 2020-9-16
-	mov		word [bp - DAP_BUFFER_OFF], DATA_BUF_OFF
-
-	;mov	eax, dword [BS_RootClus]	;deleted by mingxuan 2020-9-16
-	mov		eax, dword [fs:BS_RootClus]	;modified by mingxuan 2020-9-16
-
-	mov		dword [bp - CURRENT_CLUSTER], eax
-
-_NEXT_ROOT_CLUSTER:
-	dec 	eax
-	dec 	eax
-	xor		ebx, ebx
-
-	;mov	bl, byte [BPB_SecPerClu]	;deleted by mingxuan 2020-9-16
-	mov		bl, byte [fs:BPB_SecPerClu] ;modified by mingxuan 2020-9-16
-
-	mul		ebx
-	;add		eax, DATA_START_SECTOR
-	add		eax, [DATA_START_SECTOR] ;modified by mingxuan 2020-9-17
-	mov		dword [BP - DAP_SECTOR_LOW], eax
-
-	;mov	dl, [BPB_SecPerClu] ;deleted by mingxuan 2020-9-16
-	mov		dl, [fs:BPB_SecPerClu] ;modified by mingxuan 2020-9-16
-
-_NEXT_ROOT_SECTOR:
-	call	ReadSector
-
-	mov		di, DATA_BUF_OFF
-	mov		bl, DIR_PER_SECTOR
-
-_NEXT_ROOT_ENTRY:
-	cmp		byte [di], DIR_NAME_FREE
-	;jz		_MISSING_LOADER 	;deleted by mingxuan 2020-9-16
-	jz		_MISSING_KERNEL		;modified by mingxuan 2020-9-16
-
-	push 	di;
-
-	;cmpsb将DS:SI和ES:DI中的字符串进行比较, 故需要修改一下es, mingxuan
-	;mov		ax, ds ;added by mingxuan 2020-9-16
-	;mov		es, ax ;added by mingxuan 2020-9-16
-
-	mov		si, KernelFileName
-	mov		cx, 10
-	repe	cmpsb ;将DS:SI和ES:DI中的字符串进行比较
-
-	;把es再改回BaseOfBoot，用于索引FAT32的配置信息, mingxuan
-	;mov		ax, BaseOfBoot ;added by mingxuan 2020-9-16
-	;mov 	es, ax		   ;added by mingxuan 2020-9-16
-
-	;jcxz	_FOUND_LOADER
-	jcxz	_FOUND_KERNEL ;modified by mingxuan 2020-9-16
-
-	pop		di
-	add		di, DIR_ENTRY_SIZE
-	dec		bl
-	jnz		_NEXT_ROOT_ENTRY
-
-	dec		dl
-	jz 		_CHECK_NEXT_ROOT_CLUSTER
-	inc		dword [bp - DAP_SECTOR_LOW]
-	jmp 	_NEXT_ROOT_SECTOR
-
-_CHECK_NEXT_ROOT_CLUSTER:
-
-	 ; 计算FAT所在的簇号和偏移
-	 ; FatOffset = ClusterNum*4
-	 XOR  EDX,EDX
-	 MOV  EAX,DWORD[BP - CURRENT_CLUSTER]
-	 SHL  EAX,2
-	 XOR  ECX,ECX
-
-	 ;MOV  CX,WORD [ BPB_BytesPerSec ]	;deleted by mingxuan 2020-9-16
-	 MOV  CX,WORD [ fs:BPB_BytesPerSec ];modified by mingxuan 2020-9-16
-
-	 DIV  ECX  ; EAX = Sector EDX = OFFSET
-	 ;ADD  EAX, FAT_START_SECTOR
-	 ADD  EAX, [FAT_START_SECTOR] ;modified by mingxuan 2020-9-17
-	 MOV  DWORD [ BP - DAP_SECTOR_LOW ], EAX
-
-	 call  ReadSector
-
-	 ; 检查下一个簇
-	 MOV  DI,DX
-	 ADD  DI,DATA_BUF_OFF
-	 MOV  EAX,DWORD[DI]  ; EAX = 下一个要读的簇号
-	 AND  EAX,CLUSTER_MASK
-	 MOV  DWORD[ BP - CURRENT_CLUSTER ],EAX
-	 CMP  EAX,CLUSTER_LAST  ; CX >= 0FFFFFF8H，则意味着没有更多的簇了
-	 JB  _NEXT_ROOT_CLUSTER
-
-	 ;JMP  _MISSING_LOADER	;deleted by mingxuan 2020-9-16
-	 JMP  _MISSING_KERNEL	;modified by mingxuan 2020-9-16
-
-;_FOUND_LOADER:
-_FOUND_KERNEL: ;modified by mingxuan 2020-9-16
-	 ; 目录结构地址放在DI中
-	 pop  di
-	 xor  eax, eax
-	 mov  ax, [di + OFF_START_CLUSTER_HIGH] ; 起始簇号高32位
-	 shl  ax, 16
-	 mov  ax, [di + OFF_START_CLUSTER_LOW]  ; 起始簇号低32位
-	 mov  dword [ bp - CURRENT_CLUSTER ], eax
-	 mov  cx, BaseOfKernelFile      ; CX  = 缓冲区段地址
-
-_NEXT_DATA_CLUSTER:
-	 ; 根据簇号计算扇区号
-	 DEC  EAX
-	 DEC  EAX
-	 XOR  EBX,EBX
-
-	 ;MOV  BL, BYTE [ BPB_SecPerClu ] ;deleted by mingxuan 2020-9-16
-	 MOV  BL, BYTE [ fs:BPB_SecPerClu ];modified by mingxuan 2020-9-16
-
-	 MUL  EBX
-	 ;ADD  EAX, DATA_START_SECTOR
-	 ADD  EAX, [DATA_START_SECTOR] ;modified by mingxuan 2020-9-17
-	 MOV  DWORD[ BP - DAP_SECTOR_LOW  ], EAX
-
-	 ;MOV  BL , BYTE [BPB_SecPerClu]	;deleted by mingxuan 2020-9-16
-	 MOV  BL , BYTE [fs:BPB_SecPerClu] ;modified by mingxuan 2020-9-16
-
-	 ; 设置缓冲区
-	 MOV  WORD [ BP - DAP_BUFFER_SEG   ], CX
-	 MOV  WORD [ BP - DAP_BUFFER_OFF   ], OffsetOfKernelFile
-
-_NEXT_DATA_SECTOR:
-	 ; 读取簇中的每个扇区(内层循环)
-	 ; 注意 : 通过检查文件大小，可以避免读取最后一个不满簇的所有大小
-	 call  ReadSector
-
-	 ; 更新地址，继续读取
-	 ;MOV  AX, WORD [BPB_BytesPerSec] ;deleted by mingxuan 2020-9-16
-	 MOV  AX, WORD [fs:BPB_BytesPerSec] ;modified by mingxuan 2020-9-16
-
-	 ADD  WORD  [BP - DAP_BUFFER_OFF], ax
-	 INC  DWORD [BP - DAP_SECTOR_LOW]  ; 递增扇区号
-	 DEC  BL        ; 内层循环计数
-	 JNZ  _NEXT_DATA_SECTOR
-
-	 ; 更新读取下一个簇的缓冲区地址
-	 ;MOV  CL, BYTE [ BPB_SecPerClu ]	;deleted by mingxuan 2020-9-16
-	 MOV  CL, BYTE [ fs:BPB_SecPerClu ] ;modified by mingxuan 2020-9-16
-
-	 ;MOV  AX, WORD [BPB_BytesPerSec]	;deleted by mingxuan 2020-9-16
-	 MOV  AX, WORD [fs:BPB_BytesPerSec] ;modified by mingxuan 2020-9-16
-
-	 SHR  AX, 4
-	 MUL  CL
-	 ADD  AX, WORD [ BP - DAP_BUFFER_SEG ]
-	 MOV  CX, AX ; 保存下一个簇的缓冲区段地址
-
-	 ;====================================================================
-	 ; 检查是否还有下一个簇(读取FAT表的相关信息)
-	 ;  LET   N = 数据簇号
-	 ;  THUS FAT_BYTES  = N*4  (FAT32)
-	 ;  FAT_SECTOR = FAT_BYTES / BPB_BytesPerSec
-	 ;  FAT_OFFSET = FAT_BYTES % BPB_BytesPerSec
-	 ;====================================================================
-
-	 ; 计算FAT所在的簇号和偏移
-	 MOV  EAX,DWORD [BP - CURRENT_CLUSTER]
-	 XOR  EDX,EDX
-	 SHL  EAX,2
-	 XOR  EBX,EBX
-
-	 ;MOV  BX,WORD [ BPB_BytesPerSec ]	;deleted by mingxuan 2020-9-16
-	 MOV  BX,WORD [ fs:BPB_BytesPerSec ];modified by mingxuan 2020-9-16
-
-	 DIV  EBX   ; EAX = Sector  EDX = Offset
-
-	 ; 设置缓冲区地址
-	 ;ADD  EAX, FAT_START_SECTOR
-	 ADD  EAX, [FAT_START_SECTOR] ;modified by mingxuan 2020-9-17
-	 MOV  DWORD [ BP - DAP_SECTOR_LOW ], EAX
-	 MOV  WORD [BP - DAP_BUFFER_SEG  ], 0x09000
-	 MOV  WORD [BP - DAP_BUFFER_OFF  ], DATA_BUF_OFF
-
-	 ; 读取扇区
-	 CALL  ReadSector
-
-	 ; 检查下一个簇
-	 MOV  DI,DX
-	 ADD  DI,DATA_BUF_OFF
-	 MOV  EAX,DWORD[DI]  ; EAX = 下一个要读的簇号
-	 AND  EAX,CLUSTER_MASK
-	 MOV  DWORD[ BP - CURRENT_CLUSTER ],EAX
-	 CMP  EAX,CLUSTER_LAST  ; CX >= 0FFFFFF8H，则意味着没有更多的簇了
-	 JB  _NEXT_DATA_CLUSTER
-
-
-;;add end add by liang 2016.04.20
-; 下面准备跳入保护模式 -------------------------------------------
-
-	;for test
-	;added by mingxuan 2020-9-11
-	;mov		dh, 1
-	;call 	DispStrRealMode
-	;jmp 	$
-
-
-; 加载 GDTR
-	lgdt	[GdtPtr]
-
-; 关中断
-	cli
-
-; 打开地址线A20
-	in	al, 92h
-	or	al, 00000010b
-	out	92h, al
-
-; 准备切换到保护模式
-	mov	eax, cr0
-	or	eax, 1
-	mov	cr0, eax
-
-; 真正进入保护模式
-	jmp	dword SelectorFlatC:(BaseOfLoaderPhyAddr+LABEL_PM_START)
-
-
-;============================================================================
-;变量
-;----------------------------------------------------------------------------
-wSectorNo		dw	0		; 要读取的扇区号
-bOdd			db	0		; 奇数还是偶数
-dwKernelSize		dd	0		; KERNEL.BIN 文件大小
-_dwEchoSize		dd	0		;echo size    add by liang 2016.04.20
-;============================================================================
-;字符串
-;----------------------------------------------------------------------------
-
-; this is generated by build tools, defines KernelFileName as FAT name of the kernel
-%include "kernel_file.inc"
-
-; 为简化代码, 下面每个字符串的长度均为 MessageLength
-MessageLength		equ	9
-LoadMessage:		db	"Loading  "
-Message1		db	"Ready.   "
-Message2		db	"No KERNEL"
-Message3		db	"exLoading"		;add by liang 2016.04.20
-Message4		db	"exReady. "		;add by liang 2016.04.20
-Message5		db	"No ECHO  "		;add by liang 2016.04.20
-;============================================================================
-
-;----------------------------------------------------------------------------
-; 函数名: DispStrRealMode
-;----------------------------------------------------------------------------
-; 运行环境:
-;	实模式（保护模式下显示字符串由函数 DispStr 完成）
-; 作用:
-;	显示一个字符串, 函数开始时 dh 中应该是字符串序号(0-based)
-DispStrRealMode:
-	mov		ax, MessageLength
-	mul		dh
-	add		ax, LoadMessage
-	mov		bp, ax			; ┓
-	mov		ax, ds			; ┣ ES:BP = 串地址
-	mov		es, ax			; ┛
-	mov		cx, MessageLength	; CX = 串长度
-	mov		ax, 01301h		; AH = 13,  AL = 01h
-	mov		bx, 0007h		; 页号为0(BH = 0) 黑底白字(BL = 07h)
-	mov		dl, 0
-	add		dh, 3			; 从第 3 行往下显示
-	int		10h			; int 10h
-	ret
-;----------------------------------------------------------------------------
-
-
-;----------------------------------------------------------------------------
-; 函数名: KillMotor
-;----------------------------------------------------------------------------
-; 作用:
-;	关闭软驱马达
-KillMotor:
-	push	dx
-	mov	dx, 03F2h
-	mov	al, 0
-	out	dx, al
-	pop	dx
-	ret
-;----------------------------------------------------------------------------
-
-; 从此以后的代码在保护模式下执行 ----------------------------------------------------
-; 32 位代码段. 由实模式跳入 ---------------------------------------------------------
-[SECTION .s32]
-
-ALIGN	32
-
-[BITS	32]
-
-LABEL_PM_START:
-	mov		ax, SelectorVideo
-	mov		gs, ax
-	mov		ax, SelectorFlatRW
-	mov		ds, ax
-	mov		es, ax
-	mov		fs, ax
-	mov		ss, ax
-	mov		esp, TopOfStack
-
-	push	szMemChkTitle
-	call	DispStr
-	add		esp, 4
-
-	call	DispMemInfo
-	call	getFreeMemInfo			;add by liang 2016.04.13
-	call	DispEchoSize			;add by liang 2016.04.21
-	call	SetupPaging
-
-	; added by mingxuan 2020-9-16
-	; for test
-	mov	ah, 0Fh				; 0000: 黑底    1111: 白字
-	mov	al, 'P'
-	mov	[gs:((80 * 0 + 39) * 2)], ax	; 屏幕第 0 行, 第 39 列。
-
-	call	InitKernel
-
-	;jmp	$
-
-	;***************************************************************
-	jmp	SelectorFlatC:KernelEntryPointPhyAddr	; 正式进入内核 *
-	;***************************************************************
-	; 内存看上去是这样的：
-	;              ┃                                    ┃
-	;              ┃                 .                  ┃
-	;              ┃                 .                  ┃
-	;              ┃                 .                  ┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
-	;              ┃■■■■■■Page  Tables■■■■■■■■■■■■■■■■■■┃
-	;              ┃■■■■■(大小由LOADER决定)■■■■■■■■■■■■■┃
-	;    00101000h ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃ PageTblBase
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
-	;    00100000h ┃■■■■Page Directory Table■■■■■■■■■■■■┃ PageDirBase  <- 1M
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
-	;       F0000h ┃□□□□□□□System ROM□□□□□□□□□□□□□□□□□□□┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
-	;       E0000h ┃□□□□Expansion of system ROM □□□□□□□□┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
-	;       C0000h ┃□□□Reserved for ROM expansion□□□□□□□┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃ B8000h ← gs
-	;       A0000h ┃□□□Display adapter reserved□□□□□□□□□┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
-	;       9FC00h ┃□□extended BIOS data area (EBDA)□□□□┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
-	;       90000h ┃■■■■■■■LOADER.BIN■■■■■■■■■■■■■■■■■■■┃ somewhere in LOADER ← esp
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
-	;       80000h ┃■■■■■■■KERNEL.BIN■■■■■■■■■■■■■■■■■■■┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
-	;       30000h ┃■■■■■■■■KERNEL■■■■■■■■■■■■■■■■■■■■■■┃ 30400h ← KERNEL 入口 (KernelEntryPointPhyAddr)
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃                                    ┃
-	;        7E00h ┃              F  R  E  E            ┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
-	;        7C00h ┃■■■■■■BOOT  SECTOR■■■■■■■■■■■■■■■■■■┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃                                    ┃
-	;         500h ┃              F  R  E  E            ┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
-	;         400h ┃□□□□ROM BIOS parameter area □□□□□□□□┃
-	;              ┣━━━━━━━━━━━━━━━━━━┫
-	;              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃
-	;           0h ┃◇◇◇◇◇◇Int  Vectors◇◇◇◇◇◇┃
-	;              ┗━━━━━━━━━━━━━━━━━━┛ ← cs, ds, es, fs, ss
-	;
-	;
-	;		┏━━━┓				┏━━━┓
-	;		┃■■■■■■┃ 我们使用 	┃□□□□□□┃ 不能使用的内存
-	;		┗━━━┛				┗━━━┛
-	;		┏━━━┓				┏━━━┓
-	;		┃      ┃ 未使用空间	┃◇◇◇┃ 可以覆盖的内存
-	;		┗━━━┛				┗━━━┛
-	;
-	; 注：KERNEL 的位置实际上是很灵活的，可以通过同时改变 LOAD.INC 中的 KernelEntryPointPhyAddr 和 MAKEFILE 中参数 -Ttext 的值来改变。
-	;     比如，如果把 KernelEntryPointPhyAddr 和 -Ttext 的值都改为 0x400400，则 KERNEL 就会被加载到内存 0x400000(4M) 处，入口在 0x400400。
-	;
-
-
-
-
-; ------------------------------------------------------------------------
-; 显示 AL 中的数字
-; ------------------------------------------------------------------------
-DispAL:
-	push	ecx
-	push	edx
-	push	edi
-
-	mov	edi, [dwDispPos]
-
-	mov	ah, 0Fh			; 0000b: 黑底    1111b: 白字
-	mov	dl, al
-	shr	al, 4
-	mov	ecx, 2
-.begin:
-	and	al, 01111b
-	cmp	al, 9
-	ja	.1
-	add	al, '0'
-	jmp	.2
-.1:
-	sub	al, 0Ah
-	add	al, 'A'
-.2:
-	mov	[gs:edi], ax
-	add	edi, 2
-
-	mov	al, dl
-	loop	.begin
-	;add	edi, 2
-
-	mov	[dwDispPos], edi
-
-	pop	edi
-	pop	edx
-	pop	ecx
-
-	ret
-; DispAL 结束-------------------------------------------------------------
-
-
-; ------------------------------------------------------------------------
-; 显示一个整形数
-; ------------------------------------------------------------------------
-DispInt:
-	mov	eax, [esp + 4]
-	shr	eax, 24
-	call	DispAL
-
-	mov	eax, [esp + 4]
-	shr	eax, 16
-	call	DispAL
-
-	mov	eax, [esp + 4]
-	shr	eax, 8
-	call	DispAL
-
-	mov	eax, [esp + 4]
-	call	DispAL
-
-	mov	ah, 07h			; 0000b: 黑底    0111b: 灰字
-	mov	al, 'h'
-	push	edi
-	mov	edi, [dwDispPos]
-	mov	[gs:edi], ax
-	add	edi, 4
-	mov	[dwDispPos], edi
-	pop	edi
-
-	ret
-; DispInt 结束------------------------------------------------------------
-
-; ------------------------------------------------------------------------
-; 显示一个字符串
-; ------------------------------------------------------------------------
-DispStr:
-	push	ebp
-	mov	ebp, esp
-	push	ebx
-	push	esi
-	push	edi
-
-	mov	esi, [ebp + 8]	; pszInfo
-	mov	edi, [dwDispPos]
-	mov	ah, 0Fh
-.1:
-	lodsb
-	test	al, al
-	jz	.2
-	cmp	al, 0Ah	; 是回车吗?
-	jnz	.3
-	push	eax
-	mov	eax, edi
-	mov	bl, 160
-	div	bl
-	and	eax, 0FFh
-	inc	eax
-	mov	bl, 160
-	mul	bl
-	mov	edi, eax
-	pop	eax
-	jmp	.1
-.3:
-	mov	[gs:edi], ax
-	add	edi, 2
-	jmp	.1
-
-.2:
-	mov	[dwDispPos], edi
-
-	pop	edi
-	pop	esi
-	pop	ebx
-	pop	ebp
-	ret
-; DispStr 结束------------------------------------------------------------
-
-; ------------------------------------------------------------------------
-; 换行
-; ------------------------------------------------------------------------
-DispReturn:
-	push	szReturn
-	call	DispStr			;printf("\n");
-	add	esp, 4
-
-	ret
-; DispReturn 结束---------------------------------------------------------
-
-
-; ------------------------------------------------------------------------
-; 内存拷贝，仿 memcpy
-; ------------------------------------------------------------------------
-; void* MemCpy(void* es:pDest, void* ds:pSrc, int iSize);
-; ------------------------------------------------------------------------
-MemCpy:
-	push	ebp
-	mov	ebp, esp
-
-	push	esi
-	push	edi
-	push	ecx
-
-	mov	edi, [ebp + 8]	; Destination
-	mov	esi, [ebp + 12]	; Source
-	mov	ecx, [ebp + 16]	; Counter
-.1:
-	cmp	ecx, 0		; 判断计数器
-	jz	.2		; 计数器为零时跳出
-
-	mov	al, [ds:esi]		; ┓
-	inc	esi			; ┃
-					; ┣ 逐字节移动
-	mov	byte [es:edi], al	; ┃
-	inc	edi			; ┛
-
-	dec	ecx		; 计数器减一
-	jmp	.1		; 循环
-.2:
-	mov	eax, [ebp + 8]	; 返回值
-
-	pop	ecx
-	pop	edi
-	pop	esi
-	mov	esp, ebp
-	pop	ebp
-
-	ret			; 函数结束，返回
-; MemCpy 结束-------------------------------------------------------------
-
-;;;;;;;;;;;;;;;;;add begin add by liang 2016.04.13;;;;;;;;;;;;;;;;;;;;;
-
-memtest:
-	push	edi
-	push	esi
-
-	mov	esi,0xaa55aa55
-	mov	edi,0x55aa55aa
-	mov	eax,[esp+8+4]		;start
-.mt_loop:
-	mov	ebx,eax
-	add	ebx,0xffc		;检查每4KB最后4B
-	mov	ecx,[ebx]		;保存原值
-	mov	[ebx],esi		;写入
-	xor	dword [ebx],0xffffffff	;反转
-	cmp	edi,[ebx]		;检查反转结果是否正确
-	jne	.mt_fin
-	xor	dword [ebx],0xffffffff	;再次反转
-	cmp	esi,[ebx]		;检查是否恢复初始值
-	jne	.mt_fin
-	mov	[ebx],ecx		;恢复为修改前的值
-	add	eax,0x1000		;每循环一次加0x1000
-	cmp	eax,[esp+8+8]		;未到end，循环
-	jbe	.mt_loop
-	pop	esi
-	pop	edi
-	ret
-
-.mt_fin:
-	mov	[ebx],ecx		;恢复为修改前的值
-	pop	esi
-	pop	edi
-	ret
-
-getFreeMemInfo:
-	push	eax
-	push	ebx
-	push	ecx
-	push	edx
-
-	mov	eax,cr0
-	or	eax,0x60000000	;禁止缓存
-	mov	cr0,eax
-
-	mov	ebx,0x00000000	;检查0到32M
-	mov	ecx,0x02000000
-	mov	edx,FMIBuff	;存于0x007ff000处
-
-.fmi_loop:
-	push	ecx
-	push	ebx
-	call	memtest
-	pop	ebx
-	pop	ecx
-	mov	[edx+4],eax	;留出前4B存放dwFMINumber
-	add	edx,4
-	add	eax,0x1000
-	mov	ebx,eax
-	inc	dword [dwFMINumber]	;循环次数，即返回值个数
-	cmp	ebx,ecx
-	jb	.fmi_loop
-
-	mov	ebx,[dwFMINumber]
-	mov	edx,FMIBuff
-	mov	[edx],ebx		;前4B存放返回值个数
-	mov	ebx,[FMIBuff]
-	push	ebx
-	call	DispInt			;打印返回值个数
-	add	esp,4
-
-	mov	eax,cr0
-	and	eax,0x9fffffff	;恢复缓存
-	mov	cr0,eax
-
-	pop	edx
-	pop	ecx
-	pop	ebx
-	pop	eax
-	ret
-
-
-;;;;;;;;;;;;;;;;;;;;;;;;;;add end add by liang 2016.04.13;;;;;;;;;;;;;;;;;;;;;;;;;;
-
-;;add begin add by liang 2016.04.21
-DispEchoSize:
-	push	eax
-	mov	eax,[dwEchoSize]
-	push	eax
-	call	DispInt
-	add	esp,4
-	pop	eax
-	ret
-;;add end add by liang 2016.04.21
-
-; 显示内存信息 --------------------------------------------------------------
-DispMemInfo:
-	push	esi
-	push	edi
-	push	ecx
-
-	mov	esi, MemChkBuf
-	mov	ecx, [dwMCRNumber]	;for(int i=0;i<[MCRNumber];i++) // 每次得到一个ARDS(Address Range Descriptor Structure)结构
-.loop:					;{
-	mov	edx, 5			;	for(int j=0;j<5;j++)	// 每次得到一个ARDS中的成员，共5个成员
-	mov	edi, ARDStruct		;	{			// 依次显示：BaseAddrLow，BaseAddrHigh，LengthLow，LengthHigh，Type
-.1:					;
-	push	dword [esi]		;
-	call	DispInt			;		DispInt(MemChkBuf[j*4]); // 显示一个成员
-	pop	eax			;
-	stosd				;		ARDStruct[j*4] = MemChkBuf[j*4];
-	add	esi, 4			;
-	dec	edx			;
-	cmp	edx, 0			;
-	jnz	.1			;	}
-	call	DispReturn		;	printf("\n");
-	cmp	dword [dwType], 1	;	if(Type == AddressRangeMemory) // AddressRangeMemory : 1, AddressRangeReserved : 2
-	jne	.2			;	{
-	mov	eax, [dwBaseAddrLow]	;
-	add	eax, [dwLengthLow]	;
-	cmp	eax, [dwMemSize]	;		if(BaseAddrLow + LengthLow > MemSize)
-	jb	.2			;
-	mov	[dwMemSize], eax	;			MemSize = BaseAddrLow + LengthLow;
-.2:					;	}
-	loop	.loop			;}
-					;
-	call	DispReturn		;printf("\n");
-	push	szRAMSize		;
-	call	DispStr			;printf("RAM size:");
-	add	esp, 4			;
-					;
-	push	dword [dwMemSize]	;
-	call	DispInt			;DispInt(MemSize);
-	add	esp, 4			;
-
-	pop	ecx
-	pop	edi
-	pop	esi
-	ret
-; ---------------------------------------------------------------------------
-
-; 启动分页机制 --------------------------------------------------------------
-SetupPaging:
-	; 根据内存大小计算应初始化多少PDE以及多少页表
-	xor	edx, edx
-	mov	eax, [dwMemSize]
-	mov	ebx, 400000h	; 400000h = 4M = 4096 * 1024, 一个页表对应的内存大小
-	div	ebx
-	mov	ecx, eax	; 此时 ecx 为页表的个数，也即 PDE 应该的个数
-	test	edx, edx
-	jz	.no_remainder
-	inc	ecx		; 如果余数不为 0 就需增加一个页表
-.no_remainder:
-	push	ecx		; 暂存页表个数
-	mov dword[PageTblNumAddr],ecx ;将页表数写进这个物理地址
-
-	; 为简化处理, 所有线性地址对应相等的物理地址. 并且不考虑内存空洞.
-
-	; 首先初始化页目录
-	mov	ax, SelectorFlatRW
-	mov	es, ax
-	mov	edi, PageDirBase	; 此段首地址为 PageDirBase
-	xor	eax, eax
-	mov	eax, PageTblBase | PG_P  | PG_USU | PG_RWW
-.1:
-	stosd
-	add	eax, 4096		; 为了简化, 所有页表在内存中是连续的.
-	loop	.1
-
-;;;;初始化3G处的页目录;;;;;;;;;;;;;;;;	//add by visual 2016.5.10
-	pop eax			;页表个数
-	mov ecx,eax 	;重新放到ecx里
-	push ecx		;暂存页表个数
-	mov	ax, SelectorFlatRW
-	mov	es, ax
-	mov eax, 3072				;768*4
-	add eax, PageDirBase		;
-	mov	edi, eax				; 应该往页目录这个位置写： PageDirBase+768*4，即线性地址3G处
-
-	xor	eax, eax				; 清0
-	mov eax, ecx				;
-	mov ebx, 4096				;
-	mul ebx						;跳过前ecx个页表，即PageTblBase+页表数*4096
-	add eax, PageTblBase | PG_P  | PG_USU | PG_RWW;
-.1k:
-	stosd
-	add	eax, 4096		; 为了简化, 所有页表在内存中是连续的.
-	loop	.1k
-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
-	; 再初始化所有页表（最开始处，一一映射的）
-	pop	eax			; 页表个数
-	push eax 		;暂存页表个数
-	mov	ebx, 1024		; 每个页表 1024 个 PTE
-	mul	ebx
-	mov	ecx, eax		; PTE个数 = 页表个数 * 1024
-	mov	edi, PageTblBase	; 此段首地址为 PageTblBase
-	xor	eax, eax
-	mov	eax, PG_P  | PG_USU | PG_RWW
-.2:
-	stosd
-	add	eax, 4096		; 每一页指向 4K 的空间
-	loop	.2
-
-;;;;初始化3G处的页表;;;;;;;;;;;;;;;;	//add by visual 2016.5.10
-	; 再初始化3G后的页表
-	pop	eax			; 页表个数
-	mov	ebx, 1024		; 每个页表 1024 个 PTE
-	mul	ebx
-	mov	ecx, eax		; PTE个数 = 页表个数 * 1024
-
-	xor	eax, eax				; 清0
-	mov eax, ecx				;
-	mov ebx, 4
-	mul ebx				;跳过前ecx个页表，即PageTblBase+页表数*4096
-	add eax, PageTblBase		; 后面3G对应页表的起始位置为 PageTblBase+页表数*4096
-	mov	edi, eax
-	xor	eax, eax
-	mov	eax, PG_P  | PG_USU | PG_RWW		;从0开始
-.2k:
-	stosd
-	add	eax, 4096		; 每一页指向 4K 的空间
-	loop	.2k
-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
-	;mov	ah, 0Fh				; 0000: 黑底    1111: 白字
-	;mov	al, 'P'
-	;mov	[gs:((80 * 0 + 39) * 2)], ax	; 屏幕第 0 行, 第 39 列。
-
-	;启动页表机制
-	mov	eax, PageDirBase
-	mov	cr3, eax
-	mov	eax, cr0
-	or	eax, 80000000h
-	mov	cr0, eax
-	jmp	short .3
-.3:
-	nop
-
-	ret
-; 分页机制启动完毕 ----------------------------------------------------------
-
-
-
-; InitKernel ---------------------------------------------------------------------------------
-; 将 KERNEL.BIN 的内容经过整理对齐后放到新的位置
-; --------------------------------------------------------------------------------------------
-InitKernel:	; 遍历每一个 Program Header，根据 Program Header 中的信息来确定把什么放进内存，放到什么位置，以及放多少。
-	xor	esi, esi
-	mov	cx, word [BaseOfKernelFilePhyAddr + 2Ch]; ┓ ecx <- pELFHdr->e_phnum
-	movzx	ecx, cx								; ┛
-	mov	esi, [BaseOfKernelFilePhyAddr + 1Ch]	; esi <- pELFHdr->e_phoff
-	add	esi, BaseOfKernelFilePhyAddr			; esi <- OffsetOfKernel + pELFHdr->e_phoff
-.Begin:
-	mov	eax, [esi + 0]
-	cmp	eax, 0									; PT_NULL
-	jz	.NoAction
-	push	dword [esi + 010h]					; size	┓
-	mov	eax, [esi + 04h]						;		┃
-	add	eax, BaseOfKernelFilePhyAddr			;		┣ ::memcpy(	(void*)(pPHdr->p_vaddr),
-	push	eax									; src	┃		uchCode + pPHdr->p_offset,
-	push	dword [esi + 08h]					; dst	┃		pPHdr->p_filesz;
-	call	MemCpy								;		┃
-	add	esp, 12									;		┛
-.NoAction:
-	add	esi, 020h								; esi += pELFHdr->e_phentsize
-	dec	ecx
-	jnz	.Begin
-
-	ret
-; InitKernel ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-
-; SECTION .data1 之开始 ---------------------------------------------------------------------------------------------
-[SECTION .data1]
-
-ALIGN	32
-
-LABEL_DATA:
-; 实模式下使用这些符号
-; 字符串
-_szMemChkTitle:			db	"BaseAddrL BaseAddrH LengthLow LengthHigh   Type", 0Ah, 0
-_szRAMSize:			db	"RAM size:", 0
-_szReturn:			db	0Ah, 0
-;; 变量
-_dwMCRNumber:			dd	0	; Memory Check Result
-_dwDispPos:			dd	(80 * 6 + 0) * 2	; 屏幕第 6 行, 第 0 列。
-_dwMemSize:			dd	0
-_ARDStruct:			; Address Range Descriptor Structure
-	_dwBaseAddrLow:		dd	0
-	_dwBaseAddrHigh:	dd	0
-	_dwLengthLow:		dd	0
-	_dwLengthHigh:		dd	0
-	_dwType:		dd	0
-_MemChkBuf:	times	256	db	0
-_dwFMINumber:			dd	0		;add by liang 2016.04.13
-
-
-;
-;; 保护模式下使用这些符号
-szMemChkTitle		equ	BaseOfLoaderPhyAddr + _szMemChkTitle
-szRAMSize		equ	BaseOfLoaderPhyAddr + _szRAMSize
-szReturn		equ	BaseOfLoaderPhyAddr + _szReturn
-dwDispPos		equ	BaseOfLoaderPhyAddr + _dwDispPos
-dwMemSize		equ	BaseOfLoaderPhyAddr + _dwMemSize
-dwMCRNumber		equ	BaseOfLoaderPhyAddr + _dwMCRNumber
-ARDStruct		equ	BaseOfLoaderPhyAddr + _ARDStruct
-	dwBaseAddrLow	equ	BaseOfLoaderPhyAddr + _dwBaseAddrLow
-	dwBaseAddrHigh	equ	BaseOfLoaderPhyAddr + _dwBaseAddrHigh
-	dwLengthLow	equ	BaseOfLoaderPhyAddr + _dwLengthLow
-	dwLengthHigh	equ	BaseOfLoaderPhyAddr + _dwLengthHigh
-	dwType		equ	BaseOfLoaderPhyAddr + _dwType
-MemChkBuf		equ	BaseOfLoaderPhyAddr + _MemChkBuf
-dwFMINumber		equ	BaseOfLoaderPhyAddr + _dwFMINumber	;add by liang 2016.04.13
-dwEchoSize		equ	BaseOfLoaderPhyAddr + _dwEchoSize		;add by liang 2016.04.21
-
-; 堆栈就在数据段的末尾
-StackSpace:	times	1000h	db	0
-TopOfStack	equ	BaseOfLoaderPhyAddr + $	; 栈顶
-; SECTION .data1 之结束 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
diff --git a/boot/loader/linker.ld b/boot/loader/linker.ld
new file mode 100644
index 0000000..3ad42f5
--- /dev/null
+++ b/boot/loader/linker.ld
@@ -0,0 +1,31 @@
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(_start)
+
+ADDR_IN_PROTECT = 0x10000;
+ADDR_IN_REAL = 0;
+
+SECTIONS
+{
+	. = ADDR_IN_REAL;
+	.text.real : {
+        *(.text.real)
+    }
+
+	. = ALIGN(32);
+	. += ADDR_IN_PROTECT;
+	text_base = . - ADDR_IN_PROTECT;
+    .text : AT(text_base) {
+        *(.text)
+    }
+
+	. = ALIGN(32);
+	data_base = . - ADDR_IN_PROTECT;
+    .data : AT(data_base) {
+        *(.*)
+    }
+
+	/DISCARD/ : {
+        *(.eh_frame .note.GNU-stack)
+    }
+}
diff --git a/boot/loader/load_kernel.c b/boot/loader/load_kernel.c
new file mode 100644
index 0000000..b3713c3
--- /dev/null
+++ b/boot/loader/load_kernel.c
@@ -0,0 +1,272 @@
+#include <unios/elf.h>
+#include <arch/x86.h>
+#include <config.h>
+#include <limits.h>
+#include <stddef.h>
+#include <fat.h>
+
+static void *memset(void *v, int c, size_t n) {
+    char *p;
+    int   m;
+
+    p = v;
+    m = n;
+    while (--m >= 0) *p++ = c;
+
+    return v;
+}
+
+static void *memcpy(void *dst, const void *src, size_t n) {
+    const char *s;
+    char       *d;
+
+    s = src;
+    d = dst;
+
+    if (s < d && s + n > d) {
+        s += n;
+        d += n;
+        while (n-- > 0) *--d = *--s;
+    } else {
+        while (n-- > 0) *d++ = *s++;
+    }
+
+    return dst;
+}
+
+static int strncmp(const char *p, const char *q, size_t n) {
+    while (n > 0 && *p && *p == *q) n--, p++, q++;
+    if (n == 0)
+        return 0;
+    else
+        return (int)((unsigned char)*p - (unsigned char)*q);
+}
+
+static void waitdisk(void) {
+    // wait for disk reaady
+    while ((inb(0x1F7) & 0xC0) != 0x40) /* do nothing */
+        ;
+}
+
+#define SECTSIZE      512
+#define BUF_CLUS_ADDR ((void *)0x20000)
+#define BUF_PHDR_ADDR ((void *)0x30000)
+#define BUF_DATA_ADDR ((void *)0x40000)
+#define ELF_ADDR      ((void *)0x50000)
+
+extern uint32_t PartitionLBA;
+
+/**
+ * @brief read a sector from hd0
+ *
+ * @param dst the destination of data to load
+ * @param sector the LBA of sector to read
+ */
+static void readsect(void *dst, uint32_t sector) {
+    // wait for disk to be ready
+    waitdisk();
+
+    sector += PartitionLBA;
+    outb(0x1F2, 1); // count = 1
+    outb(0x1F3, sector);
+    outb(0x1F4, sector >> 8);
+    outb(0x1F5, sector >> 16);
+    outb(0x1F6, (sector >> 24) | 0xE0);
+    outb(0x1F7, 0x20); // cmd 0x20 - read sectors
+
+    // wait for disk to be ready
+    waitdisk();
+
+    // read a sector
+    insl(0x1F0, dst, SECTSIZE / 4);
+}
+
+uint32_t    fat_start_sec;
+uint32_t    data_start_sec;
+uint32_t    elf_clus;
+uint32_t    clus_bytes;
+fat32_BPB_t bpb;
+
+/**
+ * @brief Get the next cluster number
+ *
+ * @param clus current cluster number
+ * @return uint32_t next cluster number
+ */
+static uint32_t get_next_clus(uint32_t clus) {
+    uint32_t        sec         = clus * 4 / SECTSIZE;
+    uint32_t        off         = clus * 4 % SECTSIZE;
+    static uint32_t fat_now_sec = 0;
+    if (fat_now_sec != fat_start_sec + sec) {
+        readsect(BUF_CLUS_ADDR, fat_start_sec + sec);
+        fat_now_sec = fat_start_sec + sec;
+    }
+    return *(uint32_t *)(BUF_CLUS_ADDR + off);
+}
+
+/**
+ * @brief According to current cluster, read corresponding
+ * sectors to destination address
+ *
+ * @param dst the destination of data to load
+ * @param clus cluster number
+ * @return void* after reading, return next address can read
+ */
+static void *read_clus(void *dst, uint32_t clus) {
+    uint32_t base_sector;
+
+    base_sector  = (clus - 2) * bpb.BPB_SecPerClus;
+    base_sector += data_start_sec;
+
+    for (int i = 0; i < bpb.BPB_SecPerClus; i++, dst += SECTSIZE)
+        readsect(dst, base_sector + i);
+    return dst;
+}
+
+/**
+ * @brief According to offset in elf, get corresponding cluster number
+ *
+ * @param offset offset in elf
+ * @return uint32_t cluster number
+ */
+static uint32_t get_clus(uint32_t offset) {
+    uint32_t elf_offset = ROUNDDOWN(offset, clus_bytes);
+
+#define CLUS_CACHE_SIZE 4
+    // (elf_offset, cluster)
+    static uint32_t elf_offset_cache[CLUS_CACHE_SIZE][2] = {
+        {U32_MAX, U32_MAX},
+        {U32_MAX, U32_MAX},
+        {U32_MAX, U32_MAX},
+        {U32_MAX, U32_MAX},
+    };
+    int      hit  = -1;
+    uint32_t clus = 0;
+    for (int i = 0; i < CLUS_CACHE_SIZE; i++) {
+        if (elf_offset_cache[i][0] == elf_offset) {
+            clus = elf_offset_cache[i][1];
+            hit  = i;
+            break;
+        }
+    }
+    if (hit != -1) {
+        //! LRU
+        while (hit) {
+            elf_offset_cache[hit][0] = elf_offset_cache[hit - 1][0];
+            elf_offset_cache[hit][1] = elf_offset_cache[hit - 1][1];
+            hit--;
+        }
+        elf_offset_cache[0][0] = elf_offset;
+        elf_offset_cache[0][1] = clus;
+    } else {
+        uint32_t new_elf_offset = 0;
+        uint32_t new_clus       = elf_clus;
+        for (int i = 0; i < CLUS_CACHE_SIZE; i++) {
+            if (elf_offset_cache[i][0] < elf_offset
+                && elf_offset_cache[i][0] >= new_elf_offset) {
+                new_elf_offset = elf_offset_cache[i][0];
+                new_clus       = elf_offset_cache[i][1];
+            }
+        }
+
+        for (int i = CLUS_CACHE_SIZE - 1; i >= 1; i--) {
+            elf_offset_cache[i][0] = elf_offset_cache[i - 1][0];
+            elf_offset_cache[i][1] = elf_offset_cache[i - 1][1];
+        }
+
+        while (new_elf_offset < elf_offset) {
+            new_elf_offset += clus_bytes;
+            new_clus        = get_next_clus(new_clus);
+        }
+        elf_offset_cache[0][0] = new_elf_offset;
+        elf_offset_cache[0][1] = new_clus;
+        clus                   = new_clus;
+    }
+    return clus;
+}
+
+/**
+ * @brief read a segment from hd0, load data [offset, offset + count) (hd0)
+ * to [va, va + offset) (os)
+ *
+ * @param va address to read
+ * @param count bytes to read
+ * @param offset offset in hd0
+ */
+void readseg(void *va, uint32_t count, uint32_t offset) {
+    uint32_t end_offset = offset + count;
+    if (offset % clus_bytes != 0) {
+        uint32_t clus = get_clus(offset);
+        read_clus(BUF_DATA_ADDR, clus);
+        uint32_t n  = MIN(end_offset, ROUNDUP(offset, clus_bytes)) - offset;
+        va          = memcpy(va, BUF_DATA_ADDR + offset % clus_bytes, n);
+        offset     += n;
+    }
+    while (end_offset - offset >= clus_bytes) {
+        uint32_t clus  = get_clus(offset);
+        va             = read_clus(va, clus);
+        offset        += clus_bytes;
+    }
+    if (offset < end_offset) {
+        uint32_t clus = get_clus(offset);
+        read_clus(BUF_DATA_ADDR, clus);
+        uint32_t n  = end_offset - offset;
+        va          = memcpy(va, BUF_DATA_ADDR, n);
+        offset     += n;
+    }
+}
+
+/**
+ * @brief Get the phdr of elf
+ *
+ * @param eh pointer to ehdr
+ * @param i index of phdr
+ * @return Elf32_Phdr* pointer to phdr
+ */
+static Elf32_Phdr *get_phdr(Elf32_Ehdr *eh, int i) {
+    static uint32_t clus   = 0;
+    uint32_t        offset = eh->e_phoff + i * eh->e_phentsize;
+    if (clus != get_clus(offset)) {
+        clus = get_clus(offset);
+        read_clus(BUF_PHDR_ADDR, clus);
+        read_clus(BUF_PHDR_ADDR + clus_bytes, get_next_clus(clus));
+    }
+    return BUF_PHDR_ADDR + offset % clus_bytes;
+}
+
+void *load_kernel(void) {
+    readsect((void *)&bpb, 0);
+
+    fat_start_sec  = bpb.BPB_RsvdSecCnt;
+    data_start_sec = fat_start_sec + bpb.BPB_FATSz32 * bpb.BPB_NumFATs;
+    clus_bytes     = (uint32_t)bpb.BPB_SecPerClus * bpb.BPB_BytsPerSec;
+
+    uint32_t root_clus = bpb.BPB_RootClus;
+
+    while (root_clus < 0x0FFFFFF8) {
+        fat32_entry_t *buf_end = read_clus(BUF_DATA_ADDR, root_clus);
+        for (fat32_entry_t *p = BUF_DATA_ADDR; p < buf_end; p++) {
+            if (strncmp((void *)p->name, KERNEL_NAME_IN_FAT, 11) == 0) {
+                elf_clus = (u32)p->start_clus_hi << 16 | p->start_clus_lo;
+                break;
+            }
+        }
+        if (elf_clus != 0) break;
+        root_clus = get_next_clus(root_clus);
+    }
+
+    read_clus(ELF_ADDR, elf_clus);
+
+    Elf32_Ehdr *eh = ELF_ADDR;
+    for (int i = 0; i < eh->e_phnum; i++) {
+        Elf32_Phdr *ph = get_phdr(eh, i);
+// todo: change it to real macro
+#define PT_LOAD 1
+        if (ph->p_type != PT_LOAD) continue;
+        readseg((void *)ph->p_vaddr, ph->p_filesz, ph->p_offset);
+        memset(
+            (void *)ph->p_vaddr + ph->p_filesz, 0, ph->p_memsz - ph->p_filesz);
+    }
+
+    return (void *)eh->e_entry;
+}
diff --git a/boot/loader/loader_protect.asm b/boot/loader/loader_protect.asm
new file mode 100644
index 0000000..5c02033
--- /dev/null
+++ b/boot/loader/loader_protect.asm
@@ -0,0 +1,32 @@
+%include "loader.inc"
+
+[bits 32]
+[section .text]
+global ProtectStart
+ProtectStart:
+	mov		ax, SelectorFlatRW
+	mov		ds, ax
+	mov		ss, ax
+	mov		es, ax
+	mov		fs, ax
+	mov		gs, ax
+	mov		esp, StackTopInProtect
+	mov		[PartitionLBA], ebx
+
+SetupPaging:
+	;启动页表机制
+extern setup_paging
+	call	setup_paging
+	mov		cr3, eax
+	mov		eax, cr0
+	or		eax, 80000000h
+	mov		cr0, eax
+LoadKernel:
+extern load_kernel
+	call	load_kernel
+	; 返回值是要跳入的kernel entry
+	jmp		eax
+
+[section .data]
+global	PartitionLBA
+PartitionLBA	dd 0
diff --git a/boot/loader/loader_real.asm b/boot/loader/loader_real.asm
new file mode 100644
index 0000000..adffab6
--- /dev/null
+++ b/boot/loader/loader_real.asm
@@ -0,0 +1,93 @@
+%include "loader.inc"
+%include "pm.inc"
+
+[bits 16]
+[section .text.real]
+; 当boot将执行权交给loader时，它会将dl设置为使用的驱动器号，注意不要将其覆盖了
+; 与此同时需要注意ebx指向的是启动分区对应LBA基地址，注意不要将其覆盖了
+global _start
+_start:
+	mov		ax, cs
+	mov		ds, ax
+	mov		es, ax
+	mov		ss, ax
+	jmp		Init
+
+; GDT ------------------------------------------------------------------------------------------------------------------------------------------------------------
+;                                   段基址     段界限  属性
+LABEL_GDT:              Descriptor      0,        0, 0						; 空描述符
+LABEL_DESC_FLAT_C:      Descriptor      0,  0fffffh, DA_CR  | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
+LABEL_DESC_FLAT_RW:     Descriptor      0,  0fffffh, DA_DRW | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
+
+GdtLen	equ	$ - LABEL_GDT
+GdtPtr	dw	GdtLen - 1			; 段界限
+		dd	BaseOfLoaderPhyAddr + LABEL_GDT	; 基地址
+Init:
+	mov		sp, StackTop
+	; 将PartitionLBA变量先存栈里
+	push	ebx
+
+	; 清屏
+	mov		ax, 0600h	; AH = 6,  AL = 0h
+	mov		bx, 0700h	; 黑底白字(BL = 07h)
+	mov		cx, 0		; 左上角: (0, 0)
+	mov		dx, 0184fh	; 右下角: (80, 50)
+	int		10h			; int 10h
+
+GetDeviceInfo:
+	mov		ax, BaseOfDeviceInfo
+	mov		ds, ax
+	mov		es, ax
+	; 显卡信息
+	mov		ah, 0fh
+	int		10h
+	mov		[OffsetOfVideoCard + 0], bx; bh = display page
+	mov		[OffsetOfVideoCard + 2], ax; al = video mode, ah = window width
+	; ega/vga信息
+	mov		ah, 12h
+	mov		bl, 10h
+	int		10h
+	mov		[OffsetOfVGAInfo + 0], ax
+	mov		[OffsetOfVGAInfo + 2], bx
+	mov		[OffsetOfVGAInfo + 4], cx
+	; 内存信息
+	mov		ebx, 0
+	mov		dword [OffsetOfARDSCount], 0
+	mov 	di, OffsetOfARDSBuffer
+.MemChk:
+	mov		eax, 0E820h		; eax = 0000E820h
+	mov		ecx, 20			; ecx = 地址范围描述符结构的大小
+	mov		edx, 0534D4150h	; edx = 'SMAP'
+	int		15h				; int 15h
+	jc		.MemChkFail
+	add		di, 20
+	inc		dword [OffsetOfARDSCount]
+	cmp		ebx, 0
+	jnz		.MemChk
+.	jmp		.MemChkOK
+.MemChkFail:
+	mov		dword [OffsetOfARDSCount], 0
+.MemChkOK:
+	mov		ax, cs
+	mov		ds, ax
+	mov		es, ax
+
+InitProtectMode:
+	; 将PartitionLBA变量恢复
+	pop		ebx
+	lgdt	[GdtPtr]
+	cli
+; 打开地址线A20
+	in		al, 92h
+	or		al, 00000010b
+	out		92h, al
+; 准备切换到保护模式
+	mov		eax, cr0
+	or		eax, 1
+	mov		cr0, eax
+; 真正进入保护模式
+extern	ProtectStart
+	jmp		dword SelectorFlatC:ProtectStart
+
+Stack times 100h db 0
+StackTop:
diff --git a/boot/loader/setup_paging.c b/boot/loader/setup_paging.c
new file mode 100644
index 0000000..c7267b7
--- /dev/null
+++ b/boot/loader/setup_paging.c
@@ -0,0 +1,71 @@
+#include <unios/layout.h>
+#include <arch/device.h>
+#include <config.h>
+#include <stddef.h>
+
+static size_t get_total_memory() {
+    size_t         total_memory = 0;
+    device_info_t *device_info  = (void *)DEVICE_INFO_ADDR;
+
+    for (int i = 0; i < device_info->ARDS_count; i++) {
+        ARDS_t ards = device_info->ARDS_buffer[i];
+        if (ards.type == 1) {
+            size_t segment_limit = ards.base_addr_low + ards.length_low;
+            total_memory         = MAX(total_memory, segment_limit);
+        }
+    }
+
+    return total_memory;
+}
+
+static inline uint32_t *pg_frame_phyaddr(u32 entry) {
+    return (void *)(entry & 0xfffff000);
+}
+
+static uint32_t *alloc_free_page(void) {
+    static size_t allocator = NUM_1M;
+    uint32_t     *res;
+
+    res        = (void *)allocator;
+    allocator += NUM_4K;
+
+    //! todo: if allocator can't alloc more free pages,
+    //  print some error message and then be in a dead loop
+    while ((void *)res >= (void *)(2 * NUM_1M))
+        ; // do nothing
+
+    return res;
+}
+
+uint32_t *setup_paging(void) {
+    size_t total_memory = get_total_memory();
+    total_memory        = MIN(total_memory, 128 * NUM_1M);
+    // align to size of pde (4MB)
+    total_memory = ROUNDUP(total_memory, NUM_4M);
+
+    uint32_t *loader_cr3 = alloc_free_page();
+    uint32_t  pde_num    = total_memory / NUM_4M;
+    // identical mapping
+    for (uint32_t i = 0, mapping_addr = 0; i < pde_num; i++) {
+        uint32_t pde  = (uint32_t)alloc_free_page() | 0x3;
+        loader_cr3[i] = pde;
+        uint32_t *pd  = pg_frame_phyaddr(pde);
+        for (uint32_t j = 0; j < 1024; j++) {
+            pd[j]         = mapping_addr | 0x3;
+            mapping_addr += NUM_4K;
+        }
+    }
+    // kernel mapping
+    uint32_t kernel_pde_offset = KernelLinBase / NUM_4M;
+    for (uint32_t i = 0, mapping_addr = 0; i < pde_num; i++) {
+        uint32_t  pde = (uint32_t)alloc_free_page() | 0x3;
+        uint32_t *pd  = pg_frame_phyaddr(pde);
+
+        loader_cr3[i + kernel_pde_offset] = pde;
+        for (uint32_t j = 0; j < 1024; j++) {
+            pd[j]         = mapping_addr | 0x3;
+            mapping_addr += NUM_4K;
+        }
+    }
+    return loader_cr3;
+}
diff --git a/boot/mbr.asm b/boot/mbr.asm
index 188ac3a..64a3a33 100644
--- a/boot/mbr.asm
+++ b/boot/mbr.asm
@@ -1,261 +1,146 @@
-BaseOfBoot 					equ	1000h 		; 段地址，mbr加载loader到这个段
-OffsetOfBoot				equ	7c00h		; load Boot sector to BaseOfBoot:OffsetOfBoot
-OffsetOfActiPartStartSec	equ 7e00h		; 活动分区的起始扇区号相对于BaseOfBoot的偏移量	;added by mingxuan 2020-9-12
-											; 该变量来自分区表，保存在该内存地址，用于在os_boot和loader中查找FAT32文件
-
-org 07c00h
-
-LABEL_START:
-	mov		ax, cs
-	mov		ds, ax
-	mov		es, ax
-	mov		ss, ax
-	mov		sp, 7c00h
-
-	; 清屏
-	mov		ax, 0600h		; AH = 6,  AL = 0h
-	mov		bx, 0700h		; 黑底白字(BL = 07h)
-	mov		cx, 0			; 左上角: (0, 0)
-	mov		dx, 0184fh		; 右下角: (80, 50)
-	int		10h				; int 10h
-
-	mov		dh, 0			;
-	call 	DispStr		;
-
-
-	xor		ah, ah	; ┓
-	xor		dl, dl	; ┣ 软驱复位
-	int		13h		; ┛
-
-	;循环读取分区表
-	mov		bx, 0				;每次循环累加16
-	mov		dh, 1				;每次循环累加1
-
-	jmp CHECK_PARTITION  ;added by mingxuan 2020-9-29
-
-;added by mingxuan 2020-9-29
-LABLE_END_EXTENDED:
-
-	mov		byte [EndInExt], 0 ;将EndInExt置0，复位
-
-	; 检查扩展分区表的第二项是否是空项。如果是空项则表明当前逻辑分区就是最后一个。
-	add		bx, 16
-	mov		cl, [es:7c00h+446+bx+4]		 ;分区类型
-	;sub	bx, 16						;deleted by mingxuan 2020-9-30
-
-	cmp		cl, 0
-	jz		RESET_SecOffset_SELF
-
-CHECK_PARTITION:
-	mov		dl, [es:7c00h+446+bx]		 ;分区活跃标志地址
-
-	;mov	ax, word [es:7c00h+446+bx+8]   ;分区起始扇区地址 ;deletd by mingxuan 2020-9-12
-	mov		eax, dword [es:7c00h+446+bx+8] ;分区起始扇区地址 ;modified by mingxuan 2020-9-12
-										   ;修改为eax的原因: 分区表用4个字节来表示起始扇区，而不是2个字节, mingxuan
-
-	;add	ax, [SecOffset]	 				;deletd by mingxuan 2020-9-12
-	;add	eax, [SecOffset] 				;modified by mingxuan 2020-9-29
-							 				;deleted by mingxuan 2020-9-29
-	mov		cl, [es:7c00h+446+bx+4]		 	;分区类型
-
-	cmp		cl, 5  				;extended partition type = 5
-	;jz		LABLE_EXTENDED
-	jz		LABLE_IN_EXTENDED	;modified by mingxuan 2020-9-29
-
-	add		eax, [SecOffset_SELF]	;added by mingxuan 2020-9-29
-
-	add		byte [CurPartNo], 1
-	add		byte [CurPartNum], 1 ; added by mingxuan 2020-9-29	;deleted by mingxuan 2020-9-30
-
-	cmp		dl, 80h
-	jz		LABLE_ACTIVE
-
-	; 检查当前的分区表是否是扩展分区的最后一个逻辑分区
-	mov		cl, [EndInExt]
-	cmp		cl, 1 				;added by mingxuan 2020-9-29
-	jz		LABLE_END_EXTENDED	;added by mingxuan 2020-9-29
-
-	cmp		dh, 4
-	jz		LABLE_NOT_FOUND
-
-	inc		dh
-	add		bx, 16
-	jmp		CHECK_PARTITION
-
-
-RESET_SecOffset_SELF:
-
-	; SecOffset_SELF置0的目的是以后又恢复到搜索主分区
-	mov 	edx, 0
-	mov 	[SecOffset_SELF], edx
-
-	mov    	dl, [EXTNum]
-	mov		al, 16
-	mul		dl
-	mov     bx, ax
+%include "mbr.inc"
+%include "boot.inc"
+%include "packet.inc"
+
+org	OffsetOfMBR
+
+; 当bios启动时，它会将dl设置为使用的驱动器号，注意不要将其覆盖了
+Start:
+	mov	ax, cs
+	mov	ds, ax
+	mov	es, ax
+	mov	ss, ax
+
+	; 将代码迁移到 BaseOfMBR 去
+	cld
+	mov	cx, 200h
+	mov	si, OffsetOfBoot
+	mov	di, OffsetOfMBR
+	rep	movsb
+
+	jmp	BaseOfMBR:Init
+
+;============================================================================
+;变量
+;----------------------------------------------------------------------------
+DriverNumber              db 0                 ; 驱动器号的临时存储位置
+;============================================================================
+;字符串
+;----------------------------------------------------------------------------
+; 为简化代码, 下面每个字符串的长度均为 MessageLength
+MessageLength             equ   11
+BootMessage:              db    "Find MBR   "
+Message1                  db    "Ready.     "
+Message2                  db    "Read Fail  "
+Message3                  db    "No Bootable"
+;============================================================================
 
-	mov		ax, 0		;added by mingxuan 2020-9-30
-	mov		es,	ax		;added by mingxuan 2020-9-30
 
-	jmp 	CHECK_PARTITION
+;----------------------------------------------------------------------------
+; 函数名: DispStr
+;----------------------------------------------------------------------------
+; 作用:
+;    显示一个字符串, 函数开始时 dh 中应该是字符串序号(从0开始)
+DispStr:
+	pusha
+	push   es
+
+	mov    ax, MessageLength
+	mul    dh
+	add    ax, BootMessage
+	mov    bp, ax
+	mov    ax, ds
+	mov    es, ax            ; ES:BP = 串地址
+	mov    cx, MessageLength ; CX = 串长度
+	mov    ax, 01301h        ; AH = 13,  AL = 01h
+	mov    bx, 0007h         ; 页号为0(BH = 0) 黑底白字(BL = 07h)
+	mov    dl, 0
+	int    10h
+
+	pop    es
+	popa
+	ret
 
+;----------------------------------------------------------------------------
+; 函数名: ReadSector
+;----------------------------------------------------------------------------
+; 作用:
+;    将磁盘的数据读入到内存中
+;    eax: 从哪个扇区开始
+;    cx: 读入多少个扇区
+;    (es:bx): 读入的缓冲区的起始地址
+ReadSector:
+	pushad
+	sub		sp, SizeOfPacket
+
+	mov		si, sp
+	mov		word [si + Packet_BufferPacketSize], SizeOfPacket
+	mov		word [si + Packet_Sectors], cx
+	mov		word [si + Packet_BufferOffset], bx
+	mov		word [si + Packet_BufferSegment], es
+	mov		dword [si + Packet_StartSectors], eax
+	mov		dword [si + Packet_StartSectors + 4], 0
+
+	mov		dl, [DriverNumber]
+	mov		ah, 42h		; 扩展读
+	int		13h
+	jc		.ReadFail	; 读取失败，简单考虑就默认bios坏了
 
-; added by mingxuan 2020-9-29
-LABLE_IN_EXTENDED:					;在分区表中发现扩展分区后，跳转到这里来执行
+	add		sp, SizeOfPacket
+	popad
+	ret
 
-	; 此时的eax有两种情况：
-	; 1) 当第一次执行该程序时，eax是从主分区表里获得的扩展分区起始的绝对地址
-	; 2) 之后的执行, eax是从扩展分区表的第二项获得的起始地址(相对于整个扩展分区起始地址偏移量)
-	; 从扩展分区表的第二项获得的起始地址是相对于整个扩展分区起始地址偏移量，所以要加上基地址
-	; 特殊情况: 当第一次进入该过程时，SecOffset_EXT的值是0。此时是从主分区表里获得的起始地址，这个地址是绝对地址。
-	add		eax, [SecOffset_EXT] ;modified by mingxuan 2020-9-29
+.ReadFail:
+	mov		dh, 2
+	call	DispStr
+	jmp	$		; 如果cf位置1，就意味着读入错误，这个时候建议直接开摆
 
-	; FirstInExt是标志位，判断是否是第一次进入该过程
-	mov		cl, [FirstInExt]
-	; 若为1，表示不是第一次进入该过程。
-	cmp		cl, 1
-	jz      LABLE_EXTENDED
+Init:
+	; 临时存放设备号
+	mov		[DriverNumber], dl
+	mov		sp, OffsetOfMBR
+	; 清屏
+	mov		ax, 0600h	; AH = 6,  AL = 0h
+	mov		bx, 0700h	; 黑底白字(BL = 07h)
+	mov		cx, 0		; 左上角: (0, 0)
+	mov		dx, 0184fh	; 右下角: (80, 50)
+	int		10h			; int 10h
 
-	; 以下是第一次进入该过程要执行的语句（仅执行一遍）
-	; 要记录下扩展分区是主分区表的第几项
-	add		byte [CurPartNum], 1		;added by mingxuan 2020-9-30
-	mov		cl, [CurPartNum]
-	mov    	[EXTNum], cl
+	mov		dh, 0
+	call	DispStr
 
-	; 当第一次进入该过程时，要记录下扩展分区的起始地址，该地址是以后所有逻辑分区的偏移量的基地址
-	mov		[SecOffset_EXT], eax
-	mov		byte [FirstInExt], 1
+	mov		si, OffsetOfMBR + StartOfMBRTable
 
-LABLE_EXTENDED:
+CheckPartition:
+	mov		dh, [si + MBRPartitionState]; 获取分区表状态
+	cmp		dh, 80h						; 是否是bootable的
+	jz		FoundBootablePartition
+	add		si, MBRPartitionEntrySize
+	cmp		si, OffsetOfMBR + EndOfMBRTable	; 检测是否遍历完
+	jnz		CheckPartition
 
-	;mov	[SecOffset], ax			;deleted by mingxuan 2020-9-12
-	;mov	[SecOffset], eax		;deleted by mingxuan 2020-9-12
-	;要记录下每个逻辑分区的起始地址，因为每次找自身时需要用这个地址做基地址。（该变量每次都要更新）
-	mov		[SecOffset_SELF], eax	;added by mingxuan 2020-9-29
+NotFoundBootablePartition:
+	mov		dh, 3
+	call	DispStr
+	jmp		$
 
-	add		byte [EbrNum], 1
-	cmp		byte [EbrNum], 1
-	jz		._add_CurPartNo
-._read_ebr:
-	mov 	cl, 1
-	mov		bx, BaseOfBoot
-	mov 	es, bx
-	mov 	bx, OffsetOfBoot
-	call 	ReadSector
-	mov		bx, 0
+FoundBootablePartition:
 	mov		dh, 1
+	call	DispStr
 
-	; 将EndInExt置1，表示此时正在扫描扩展分区，用于之后程序判断当前是否是扩展分区的终点
-	mov		[EndInExt], dh		;added by mingxuan 2020-9-29
-
-	jmp 	CHECK_PARTITION
-._add_CurPartNo:
-	add		byte [CurPartNo], 1
-	jmp		._read_ebr
-
-
-LABLE_ACTIVE:
-
-	mov 	cl, 1 			 ;要读取的扇区个数
-
+	mov		cx, 1
+	mov		eax, [si + MBRFirstLBA]
 	mov		bx, BaseOfBoot
-	mov 	es, bx
-
-	mov     dword [es:OffsetOfActiPartStartSec], eax 	;此时eax中存放活动分区的起始扇区号
-												;added by mingxuan 2020-9-12
-
-	mov 	bx, OffsetOfBoot ;对应扇区会被加载到内存的 es:bx 处
-
+	mov		es, bx
+	mov		bx, OffsetOfBoot
 	call 	ReadSector
-
-	;mov	dh, 1
-	;call	DispStr
-	;mov	dh, 2
-	;call 	DispStr
-
-	; mov	ah,0h
-	; int	16h
-
+	; 检查是否是可引导扇区
+	mov		ax, [es:OffsetOfBoot + 510]
+	cmp		ax, 0xaa55
+	jnz		NotFoundBootablePartition
+	; 将执行流交给boot前获取设备号
+	mov		dl, [DriverNumber]
+	; 此时ds:si也指向了正在启动的mbr表项
 	jmp 	BaseOfBoot:OffsetOfBoot
 
-LABLE_NOT_FOUND:
-	mov		dh, 3
-	call 	DispStr
-	jmp	$
-
-
-;SecOffset 		dw 	0 ;deletd by mingxuan 2020-9-12
-;SecOffset 		dd 	0 ;modifed by mingxuan 2020-9-29
-SecOffset_SELF 	dd 	0 ;modifed by mingxuan 2020-9-29
-SecOffset_EXT 	dd 	0 ;modifed by mingxuan 2020-9-29
-
-EbrNum		db	0
-
-FirstInExt	db  0 ;added by mingxuan 2020-9-29
-EndInExt	db	0 ;added by mingxuan 2020-9-29
-EXTNum		db  0 ;added by mingxuan 2020-9-29
-CurPartNum  db  0 ;added by mingxuan 2020-9-29
-
-MessageLength		equ	27
-BootMessage:		db	"Finding active partition..."	; 27字节, 不够则用空格补齐. 序号 0
-
-Message1			db	"    partition "
-CurPartNo			db	"0"
-					db	":     active"
-;Message2			db	"press any key to continue  "
-Message3			db	"active partition not found!"
-
-DispStr:
-	push	ax
-	push	dx
-	mov		ax, MessageLength
-	mul		dh
-	add		ax, BootMessage
-	mov		bp, ax			; ┓
-	mov		ax, ds			; ┣ ES:BP = 串地址
-	mov		es, ax			; ┛
-	mov		cx, MessageLength	; CX = 串长度
-	mov		ax, 01301h		; AH = 13,  AL = 01h
-	mov		bx, 0007h		; 页号为0(BH = 0) 黑底白字(BL = 07h)
-	mov		dl, 0
-	int		10h			; int 10h
-	pop		dx
-	pop 	ax
-	ret
-
-
-;----------------------------------------------------------------------------
-; 函数名: ReadSector (使用扩展int13 ah=42)
-;----------------------------------------------------------------------------
-; 作用:
-;	从第 ax 个 Sector 开始, 将 cl 个 Sector 读入 es:bx 中
-
-DAPS:
-	DB 0x10               		; size of packet
-    DB 0                  		; Always 0
-	D_CL	DW 1          		; number of sectors to transfer
-	D_BX	DW OffsetOfBoot     ; transfer buffer (16 bit segment:16 bit offset)
-	D_ES	DW BaseOfBoot
-	LBA_Lo	DD 1	      		; lower 32-bits of 48-bit starting LBA
-	LBA_Hi	DD 0	      		; upper 32-bits of 48-bit starting LBAs
-
-ReadSector:
-	mov	[D_CL],   cl
-	mov	[D_BX],   bx
-	mov	[D_ES],   es
-	;mov	[LBA_Lo], ax	;deleted by mingxuan 2020-9-17
-	mov	[LBA_Lo], eax		;modified by mingxuan 2020-9-17
-							;修改为eax的原因: 分区表用4个字节来表示起始扇区，而不是2个字节, mingxuan
-	mov	dl, 0x80
-
-.GoOnReading:
-	mov		ah, 42h
-	mov 	si, DAPS
-	int		13h
-	jc	.GoOnReading		; 如果读取错误 CF 会被置为 1, 这时就不停地读, 直到正确为止
-
-	ret
-
-
-times 444 -($-$$) db 0
-dw 0x0000
+times SizeOfMBR -($-$$) db 0
diff --git a/include/fs/fat.h b/include/fs/fat.h
index 8b0e61e..1e7d2ab 100644
--- a/include/fs/fat.h
+++ b/include/fs/fat.h
@@ -31,7 +31,39 @@ enum fat32_entry_attr {
     ATTR_ARCHIVE = 1 << 5, //<! archive
 };
 
-typedef struct fat32_entry_s {
+typedef struct {
+    u8  BS_jmpBoot[3];
+    u8  BS_OEMName[8];
+    u16 BPB_BytsPerSec;
+    u8  BPB_SecPerClus;
+    u16 BPB_RsvdSecCnt;
+    u8  BPB_NumFATs;
+    u16 BPB_RootEntCnt;
+    u16 BPB_TotSec16;
+    u8  BPB_Media;
+    u16 BPB_FATSz16;
+    u16 BPB_SecPerTrk;
+    u16 BPB_NumHeads;
+    u32 BPB_HiddSec;
+    u32 BPB_TotSec32;
+    u32 BPB_FATSz32;
+    u16 BPB_ExtFlags;
+    u16 BPB_FSVer;
+    u32 BPB_RootClus;
+    u16 BPB_FSInfo;
+    u16 BPB_BkBootSec;
+    u8  BPB_Reserved[12];
+    u8  BS_DrvNum;
+    u8  BS_Reserved1;
+    u8  BS_BootSig;
+    u32 BS_VolID;
+    u8  BS_VolLabp[11];
+    u8  BS_FilSysType[8];
+    u8  zero[420];
+    u16 Signature_word;
+} __attribute__((packed)) fat32_BPB_t;
+
+typedef struct {
     u8  name[8];            //<! file name
     u8  ext[3];             //<! extension
     u8  attr;               //<! attribute, compound with fat32_entry_attr
@@ -47,7 +79,7 @@ typedef struct fat32_entry_s {
     u32 size;               //<! file size, in bytes
 } fat32_entry_t;
 
-typedef struct fat32_lfn_entry_s {
+typedef struct {
     u8  attr;       //<! attribute, compound with fat32_entry_attr
     u8  name1[10];  //<! 1st name part
     u8  flag;       //<! lfn entry flag, always 0x0f
diff --git a/include/kernel/arch/device.h b/include/kernel/arch/device.h
new file mode 100644
index 0000000..53ee033
--- /dev/null
+++ b/include/kernel/arch/device.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include <stdint.h>
+
+typedef struct {
+    uint32_t base_addr_low;
+    uint32_t base_addr_high;
+    uint32_t length_low;
+    uint32_t length_high;
+    uint32_t type;
+} ARDS_t;
+
+typedef struct {
+    uint8_t  video_card[4];
+    uint8_t  vga_info[6];
+    uint32_t ARDS_count;
+    ARDS_t   ARDS_buffer[0];
+} __attribute__((packed)) device_info_t;
diff --git a/include/kernel/config.h.in b/include/kernel/config.h.in
index 8d9136e..0118be9 100644
--- a/include/kernel/config.h.in
+++ b/include/kernel/config.h.in
@@ -5,3 +5,9 @@
 #define INSTALL_NR_SECTORS   @INSTALL_NR_SECTORS@
 #define PART_START_SECTOR    @PART_START_SECTOR@
 #define INSTALL_START_SECTOR @INSTALL_START_SECTOR@
+
+//!NOTE: this var is closely integrated with loader,
+// so if you should read loader carefully before modifying this var.
+#define DEVICE_INFO_ADDR     @DEVICE_INFO_ADDR@
+
+#define KERNEL_NAME_IN_FAT   @KERNEL_NAME_IN_FAT@
diff --git a/include/kernel/unios/elf.h b/include/kernel/unios/elf.h
index 6852a1b..e5f9c53 100644
--- a/include/kernel/unios/elf.h
+++ b/include/kernel/unios/elf.h
@@ -8,51 +8,52 @@
  *		elf 头
  *****************************************/
 typedef struct {
-    u8 e_ident[EI_NIDENT]; // ELF魔数，ELF字长，字节序，ELF文件版本等
-    u16 e_type; // ELF文件类型，REL, 可执行文件，共享目标文件等
-    u16 e_machine;   // ELF的CPU平台属性
-    u32 e_version;   // ELF版本号
-    u32 e_entry;     // ELF程序的入口虚拟地址
-    u32 e_phoff;     // program header table(program头)在文件中的偏移
-    u32 e_shoff;     // section header table(section头)在文件中的偏移
-    u32 e_flags;     // 用于标识ELF文件平台相关的属性
-    u16 e_ehsize;    // elf header（本文件头）的长度
-    u16 e_phentsize; // program header table 中每一个条目的长度
-    u16 e_phnum;     // program header table 中有多少个条目
-    u16 e_shentsize; // section header table 中每一个条目的长度
-    u16 e_shnum;     // section header table 中有多少个条目
-    u16 e_shstrndx;  // section header table 中字符索引
+    uint8_t e_ident[EI_NIDENT]; // ELF魔数，ELF字长，字节序，ELF文件版本等
+    uint16_t e_type; // ELF文件类型，REL, 可执行文件，共享目标文件等
+    uint16_t e_machine; // ELF的CPU平台属性
+    uint32_t e_version; // ELF版本号
+    uint32_t e_entry;   // ELF程序的入口虚拟地址
+    uint32_t e_phoff;   // program header table(program头)在文件中的偏移
+    uint32_t e_shoff;   // section header table(section头)在文件中的偏移
+    uint32_t e_flags;   // 用于标识ELF文件平台相关的属性
+    uint16_t e_ehsize;  // elf header（本文件头）的长度
+    uint16_t e_phentsize; // program header table 中每一个条目的长度
+    uint16_t e_phnum;     // program header table 中有多少个条目
+    uint16_t e_shentsize; // section header table 中每一个条目的长度
+    uint16_t e_shnum;     // section header table 中有多少个条目
+    uint16_t e_shstrndx;  // section header table 中字符索引
 } Elf32_Ehdr;
 
 /*******************************************
  *		program头(程序头)
  **********************************************/
 typedef struct {
-    u32 p_type;   // 该program 	类型
-    u32 p_offset; // 该program	在文件中的偏移量
-    u32 p_vaddr;  // 该program	应该放在这个线性地址
-    u32 p_paddr;  // 该program
-                 // 应该放在这个物理地址（对只使用物理地址的系统有效）
-    u32 p_filesz; // 该program	在文件中的长度
-    u32 p_memsz; // 该program	在内存中的长度（不一定和filesz相等）
-    u32 p_flags; // 该program	读写权限
-    u32 p_align; // 该program	对齐方式
+    uint32_t p_type;   // 该program 	类型
+    uint32_t p_offset; // 该program	在文件中的偏移量
+    uint32_t p_vaddr;  // 该program	应该放在这个线性地址
+    uint32_t p_paddr;  // 该program
+                      // 应该放在这个物理地址（对只使用物理地址的系统有效）
+    uint32_t p_filesz; // 该program	在文件中的长度
+    uint32_t p_memsz; // 该program	在内存中的长度（不一定和filesz相等）
+    uint32_t p_flags; // 该program	读写权限
+    uint32_t p_align; // 该program	对齐方式
 } Elf32_Phdr;
 
 /*********************************************
  *		section头(段头)
  ************************************************/
 typedef struct {
-    u32 s_name;   // 该section 段的名字
-    u32 s_type;   // 该section 的类型，代码段，数据段，符号表等
-    u32 s_flags;  // 该section 在进程虚拟地址空间中的属性
-    u32 s_addr;   // 该section 的虚拟地址
-    u32 s_offset; // 该section 在文件中的偏移
-    u32 s_size;   // 该section 的长度
-    u32 s_link;   // 该section	头部表符号链接
-    u32 s_info;   // 该section	附加信息
-    u32 s_addralign; // 该section 对齐方式
-    u32 s_entsize; // 该section 若有固定项目，则给出固定项目的大小，如符号表
+    uint32_t s_name; // 该section 段的名字
+    uint32_t s_type; // 该section 的类型，代码段，数据段，符号表等
+    uint32_t s_flags;     // 该section 在进程虚拟地址空间中的属性
+    uint32_t s_addr;      // 该section 的虚拟地址
+    uint32_t s_offset;    // 该section 在文件中的偏移
+    uint32_t s_size;      // 该section 的长度
+    uint32_t s_link;      // 该section	头部表符号链接
+    uint32_t s_info;      // 该section	附加信息
+    uint32_t s_addralign; // 该section 对齐方式
+    uint32_t
+        s_entsize; // 该section 若有固定项目，则给出固定项目的大小，如符号表
 } Elf32_Shdr;
 
 void read_Ehdr(u32 fd, Elf32_Ehdr *File_Ehdr, u32 offset);
diff --git a/include/lib/stddef.h b/include/lib/stddef.h
index 7a7b083..1dc313f 100644
--- a/include/lib/stddef.h
+++ b/include/lib/stddef.h
@@ -18,5 +18,32 @@ typedef int32_t ptrdiff_t;
 
 //! WARNING: make sure that your x, y expr no side-effect! recommand using
 //! the min/max methods provided in the math.h
-#define MIN(x, y) ((x) < (y) ? (x) : (y))
-#define MAX(x, y) ((x) > (y) ? (x) : (y))
+#define MIN(_a, _b)                \
+    ({                             \
+        __typeof__(_a) __a = (_a); \
+        __typeof__(_b) __b = (_b); \
+        __a <= __b ? __a : __b;    \
+    })
+
+#define MAX(_a, _b)                \
+    ({                             \
+        __typeof__(_a) __a = (_a); \
+        __typeof__(_b) __b = (_b); \
+        __a >= __b ? __a : __b;    \
+    })
+
+#define ROUNDDOWN(a, n)                 \
+    ({                                  \
+        u32 __a = (u32)(a);             \
+        (__typeof__(a))(__a - __a % n); \
+    })
+
+#define ROUNDUP(a, n)                                        \
+    ({                                                       \
+        u32 __n = (u32)(n);                                  \
+        (__typeof__(a))(ROUNDDOWN((u32)(a) + __n - 1, __n)); \
+    })
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
+#define offsetof(type, member) ((size_t)(&((type *)0)->member))
diff --git a/kernel/memory.c b/kernel/memory.c
index 6e3106f..2120489 100644
--- a/kernel/memory.c
+++ b/kernel/memory.c
@@ -14,7 +14,7 @@ spinlock_t kmem_lock;
 void* unsafe_kmalloc(size_t size) {
     static void* base = KMEM_BASE;
     if (KMEM_LIMIT - base < size) { return NULL; }
-    void* ptr = base;
+    void* ptr  = base;
     base      += size;
     return ptr;
 }
@@ -93,7 +93,7 @@ int mballoc_free(memblk_allocator_t* allocator, void* addr, size_t size) {
     if (index < allocator->nr_frees) {
         assert(addr + size <= after->addr);
         if (addr + size == after->addr) {
-            after->addr = addr;
+            after->addr  = addr;
             after->size += size;
             ++merged;
         }
@@ -159,6 +159,11 @@ memblk_allocator_t* mballoc_create_by(
 }
 
 void init_memory() {
+    //! NOTE: end symbol is provided by compiler, it's address is end of
+    //! elf(kernel)
+    extern int end;
+    assert((void*)&end <= KMEM_BASE);
+
     kmem_allocator =
         mballoc_create(unsafe_kmalloc, NUM_1K, KMEM_BASE, KMEM_LIMIT);
     assert(kmem_allocator != NULL);
diff --git a/project/conf-gdb.mk b/project/conf-gdb.mk
index f0f24c2..20dd17f 100644
--- a/project/conf-gdb.mk
+++ b/project/conf-gdb.mk
@@ -6,6 +6,8 @@ GDB ?= gdb
 
 GDB_SCRIPTS_HOME ?=
 
+GDB_REALMODE_XML := $(GDB_SCRIPTS_HOME)target.xml
+
 GDB_FLAGS := -q -nx
 GDB_FLAGS += -x '$(GDB_SCRIPTS_HOME)connect-qemu.gdb'
 GDB_FLAGS += -x '$(GDB_SCRIPTS_HOME)instr-level.gdb'
diff --git a/project/conf-unios.mk b/project/conf-unios.mk
index 86b9678..01d6395 100644
--- a/project/conf-unios.mk
+++ b/project/conf-unios.mk
@@ -18,7 +18,7 @@ KERNEL_FILE       := $(OBJDIR)/kernel/$(KERNEL_NAME)
 KERNEL_DEBUG_FILE := $(KERNEL_FILE)d
 
 # start address of kernel .text
-KERNEL_START_ADDR := 0xc0030400
+KERNEL_START_ADDR := 0xc0200000
 
 # standard library for uniform-os
 LIBRT_FILE := $(OBJDIR)/lib/lib$(LIBRT).a
@@ -37,11 +37,20 @@ INSTALL_NR_SECTORS     := 1000
 INSTALL_START_SECTOR := $(shell echo $$[$(INSTALL_PHY_SECTOR) - $(PART_START_SECTOR)])
 SUPER_BLOCK_ADDR     := $(shell echo $$[($(PART_START_SECTOR) + 1) * 512])
 
+DEVICE_INFO_ADDR := 0x90000
+
+KERNEL_NAME_IN_FAT := $(shell \
+    basename=$(shell echo -n $(basename $(notdir $(KERNEL_NAME))) | cut -c -8 | tr 'a-z' 'A-Z');	\
+	suffix=$(shell echo -n $(patsubst .%,%,$(suffix $(KERNEL_NAME))) | cut -c -3 | tr 'a-z' 'A-Z');	\
+	printf "\"%-*s%-*s\"" "8" "$${basename}" "3" "$${suffix}"                                       \
+)
+
 # configure toolchain
 DEFINES  ?=
 INCDIRS  ?=
 INCDIRS  += include/kernel
 INCDIRS  += include/lib
+INCDIRS  += include/fs
 INCDIRS  += include/deps
 LINKDIRS ?=
 LINKDIRS += $(OBJDIR)/lib
@@ -56,3 +65,6 @@ include $(PROJMK_PREFIX)conf-gdb.mk
 
 # libgcc, introduced mainly for some useful built-in functions
 LIBGCC_FILE := $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)
+ifeq ($(LIBGCC_FILE),)
+    $(error unios requires `gcc-multilib` to complete the build)
+endif
diff --git a/project/prepare-boot.mk b/project/prepare-boot.mk
index 533e0ec..55c9fcb 100644
--- a/project/prepare-boot.mk
+++ b/project/prepare-boot.mk
@@ -1,18 +1,23 @@
 # path to project mk files
 PROJMK_PREFIX ?=
 
-# collect bootloader objects
+# collect boot/mbr objects
 SOURCE_DIR := boot/
 OUTPUT_DIR := $(OBJDIR)/$(SOURCE_DIR)
 include $(PROJMK_PREFIX)collect-objects.mk
 
-# bootloader programs
-BOOTLOADER_SOURCES := $(SOURCE_FILES)
-BOOTLOADER_FILES   := $(patsubst %,$(OUTPUT_DIR)%.bin,$(basename $(notdir $(BOOTLOADER_SOURCES))))
+MBR_FILE    := $(OBJDIR)/boot/mbr.bin
+BOOT_FILE   := $(OBJDIR)/boot/boot.bin
 
-ASBIN_SOURCE_FILES += $(BOOTLOADER_SOURCES)
-ASBIN_FILES        += $(BOOTLOADER_FILES)
+# collect loader objects
+SOURCE_DIR := boot/loader/
+OUTPUT_DIR := $(OBJDIR)/$(SOURCE_DIR)
+include $(PROJMK_PREFIX)collect-objects.mk
+
+LOADER_SIZE_LIMIT := $(shell echo $$[0x10000])
+
+# loader objects
+LOADER_OBJECTS  := $(patsubst %,$(OBJDIR)/%.obj,$(SOURCE_FILES))
+LOADER_LINKER	:= $(SOURCE_DIR)/linker.ld
 
-# needed by loader.bin, provide kernel info to loader
-GENERATED_FILES += $(GENERATED_INCDIR)/kernel_entry.inc
-GENERATED_FILES += $(GENERATED_INCDIR)/kernel_file.inc
+LOADER_FILE := $(OBJDIR)/boot/loader.bin
diff --git a/project/prepare-fs_flags.mk b/project/prepare-fs_flags.mk
index 7bd6d69..3366a37 100644
--- a/project/prepare-fs_flags.mk
+++ b/project/prepare-fs_flags.mk
@@ -6,9 +6,4 @@ SOURCE_DIR := fs_flags/
 OUTPUT_DIR := $(OBJDIR)/$(SOURCE_DIR)
 include $(PROJMK_PREFIX)collect-objects.mk
 
-# fs flag files
-FS_FLAG_SOURCES := $(SOURCE_FILES)
-FS_FLAG_FILES   := $(patsubst %,$(OUTPUT_DIR)%.bin,$(basename $(notdir $(FS_FLAG_SOURCES))))
-
-ASBIN_SOURCE_FILES += $(FS_FLAG_SOURCES)
-ASBIN_FILES        += $(FS_FLAG_FILES)
+ORANGE_FS_FLAG_FILE := $(OBJDIR)/fs_flags/orange_flag.bin
diff --git a/project/prepare.mk b/project/prepare.mk
index 216406b..35fc709 100644
--- a/project/prepare.mk
+++ b/project/prepare.mk
@@ -4,10 +4,6 @@ PROJMK_PREFIX ?=
 # elf type .obj files
 OBJECT_FILES :=
 
-# assembly .bin files
-ASBIN_SOURCE_FILES :=
-ASBIN_FILES        :=
-
 # generated files
 GENERATED_FILES :=
 
diff --git a/project/rules-asbin.mk b/project/rules-asbin.mk
index 0f21766..1bc8dde 100644
--- a/project/rules-asbin.mk
+++ b/project/rules-asbin.mk
@@ -1,5 +1,11 @@
-$(OBJDIR)/%.bin: %.asm $(filter %.inc,$(GENERATED_FILES))
+$(OBJDIR)/%.bin: %.asm $(filter %.inc,$(GENERATED_FILES)) $(CACHED_FLAG_FILES)
 	@echo -ne "[PROC] as $(notdir $@)\r"
 	@mkdir -p $(@D)
-	@$(AS) $(ASFLAGS) -o $@ $<
+	@$(AS) $(ASFLAGS) -MD $(patsubst %.bin, %.asm.d, $@) -o $@ $<
 	@echo -e "\e[1K\r\e[32m[DONE]\e[0m as $(notdir $@)"
+
+$(LOADER_FILE): $(LOADER_OBJECTS) $(LOADER_LINKER) $(CACHED_FLAG_FILES)
+	@echo -ne "[PROC] ld $(notdir $@)\r"
+	@mkdir -p $(@D)
+	@$(LD) $(LDFLAGS) -T $(LOADER_LINKER) -s --oformat binary -o $@ $(LOADER_OBJECTS)
+	@echo -e "\e[1K\r\e[32m[DONE]\e[0m ld $(notdir $@)"
diff --git a/project/rules-gen.mk b/project/rules-gen.mk
index da86f50..4e860a8 100644
--- a/project/rules-gen.mk
+++ b/project/rules-gen.mk
@@ -14,27 +14,6 @@ $(ENVS): force
 	@echo -e "\e[1K\r\e[32m[DONE]\e[0m write out make envs";
 .PHONY: force
 
-# kernel entry address constant for loader
-$(GENERATED_INCDIR)/kernel_entry.inc: $(KERNEL_DEBUG_FILE)
-	@echo -ne "[PROC] generate $(notdir $@)\r"
-	@mkdir -p $(@D)
-	@echo -n "KernelEntryPointPhyAddr equ 0x`nm $< | grep -Po '(\w+)(?= T _start)'`" > $@
-	@echo -e "\e[1K\r\e[32m[DONE]\e[0m generate $(notdir $@)"
-
-# FAT filename of kernel for loader
-$(GENERATED_INCDIR)/kernel_file.inc: $(KERNEL_FILE)
-	@echo -ne "[PROC] generate $(notdir $@)\r"
-	@mkdir -p $(@D)
-	@\
-	basename=$(shell echo $(basename $(notdir $<)) | tr 'a-z' 'A-Z');		\
-	suffix=$(shell echo $(patsubst .%,%,$(suffix $<)) | tr 'a-z' 'A-Z');	\
-	n1=`echo -n $${basename} | wc -c`; 										\
-	n2=`echo -n $${suffix} | wc -c`; 										\
-	left=$$[11-$${n1}-$${n2}]; 												\
-	filename=`printf "%s%*s%s" "$${basename}" "$${left}" ' ' "$${suffix}"`;	\
-	echo "KernelFileName db \"$${filename}\",0" > $@
-	@echo -e "\e[1K\r\e[32m[DONE]\e[0m generate $(notdir $@)"
-
 # config.h for kernel
 # NOTE: $(ENVS) is very sensitive to the envs, be careful to update the config.h
 $(GENERATED_INCDIR)/config.h: include/kernel/config.h.in $(ENVS)
@@ -44,10 +23,9 @@ $(GENERATED_INCDIR)/config.h: include/kernel/config.h.in $(ENVS)
 	@\
 	vars=`cat $< | grep -Po '(?<=@)\w+(?=@)' | tr '\n' ' '`;	\
 	cat $(ENVS) | while IFS= read -r row; do					\
-		tuple=($${row});										\
-		key=$${tuple[0]};										\
+		read -r key value <<< 									\
+			`echo "$${row}" | awk -F' = ' '{print $$1, $$2}'`;	\
 		if [[ " $${vars} " =~ " $${key} " ]]; then				\
-			value=$${tuple[@]:2};								\
 			sed -i "s/@$${key}@/$${value}/g" $@.swp;			\
 		fi;														\
 	done;
diff --git a/project/rules-image.mk b/project/rules-image.mk
index 3660828..4fd1eae 100644
--- a/project/rules-image.mk
+++ b/project/rules-image.mk
@@ -2,12 +2,6 @@ MOUNT_POINT := $(OBJDIR)/iso
 
 RAW_HD_IMAGE := hd/test1.img
 
-MBR_FILE    := $(OBJDIR)/boot/mbr.bin
-BOOT_FILE   := $(OBJDIR)/boot/boot.bin
-LOADER_FILE := $(OBJDIR)/boot/loader.bin
-
-ORANGE_FS_FLAG_FILE := $(OBJDIR)/fs_flags/orange_flag.bin
-
 $(IMAGE_FILE)p0: $(RAW_HD_IMAGE) $(MBR_FILE) $(BOOT_FILE)
 	@echo -ne "[PROC] pre-build image\r"
 	@mkdir -p $(@D)
@@ -30,6 +24,13 @@ $(IMAGE_FILE)p0: $(RAW_HD_IMAGE) $(MBR_FILE) $(BOOT_FILE)
 
 $(IMAGE_FILE)p1: $(IMAGE_FILE)p0 $(LOADER_FILE) $(KERNEL_FILE)
 	@echo -ne "[PROC] install bootloader & kernel\r"
+	@\
+	loader_size=`stat -c "%s" $(LOADER_FILE)`;					\
+	if [ "$$loader_size" -gt "$(LOADER_SIZE_LIMIT)" ]; then		\
+		echo -en "\e[1K\r\e[31mLOADER too large";				\
+		echo -e "($${loader_size}/$(LOADER_SIZE_LIMIT))\e[0m"	\
+		exit 1;													\
+	fi
 	@mkdir -p $(@D)
 	@cp -f $< $@
 	@mkdir -p $(MOUNT_POINT)
diff --git a/project/rules-kernel.mk b/project/rules-kernel.mk
index e8809cb..dbbc01f 100644
--- a/project/rules-kernel.mk
+++ b/project/rules-kernel.mk
@@ -1,15 +1,12 @@
-# TODO: better solution
-KERNEL_START_FILE := $(OBJDIR)/kernel/kernel.asm.obj
-
 # build kernel
-$(KERNEL_FILE): $(KERNEL_START_FILE) $(KERNEL_OBJECTS) $(LIBRT_FILE) $(LIBGCC_FILE)
+$(KERNEL_FILE): $(KERNEL_OBJECTS) $(LIBRT_FILE) $(LIBGCC_FILE)
 	@echo -ne "[PROC] ld $(notdir $@)\r"
 	@mkdir -p $(@D)
 	@$(LD) $(LDFLAGS) -Ttext $(KERNEL_START_ADDR) -o $@ $^ -s
 	@echo -e "\e[1K\r\e[32m[DONE]\e[0m ld $(notdir $@)"
 
 # build kernel debug
-$(KERNEL_DEBUG_FILE): $(KERNEL_START_FILE) $(KERNEL_OBJECTS) $(LIBRT_FILE) $(LIBGCC_FILE)
+$(KERNEL_DEBUG_FILE): $(KERNEL_OBJECTS) $(LIBRT_FILE) $(LIBGCC_FILE)
 	@echo -ne "[PROC] ld $(notdir $@)\r"
 	@mkdir -p $(@D)
 	@$(LD) $(LDFLAGS) -Ttext $(KERNEL_START_ADDR) -o $@ $^
diff --git a/project/rules-obj.mk b/project/rules-obj.mk
index 12526c1..5841489 100644
--- a/project/rules-obj.mk
+++ b/project/rules-obj.mk
@@ -18,9 +18,9 @@ $(OBJDIR)/%.c.obj: %.c $(filter %.h,$(GENERATED_FILES)) $(CACHED_FLAG_FILES)
 	@$(CC) $(CFLAGS) -c -o $@ $<
 	@echo -e "\e[1K\r\e[32m[DONE]\e[0m cc $<"
 
-# [fallthrough] compile assembly objects
-$(OBJDIR)/%.obj: % $(CACHED_FLAG_FILES)
+# compile assembly objects
+$(OBJDIR)/%.asm.obj: %.asm $(filter %.inc,$(GENERATED_FILES)) $(CACHED_FLAG_FILES)
 	@echo -ne "[PROC] as $<\r"
 	@mkdir -p $(@D)
-	@$(AS) $(ASFLAGS) -f elf -o $@ $<
+	@$(AS) $(ASFLAGS) -MD $(patsubst %.obj, %.d, $@) -f elf -o $@ $<
 	@echo -e "\e[1K\r\e[32m[DONE]\e[0m as $<"
diff --git a/project/rules.mk b/project/rules.mk
index 001f381..fbbfc9d 100644
--- a/project/rules.mk
+++ b/project/rules.mk
@@ -29,6 +29,13 @@ monitor: $(KERNEL_DEBUG_FILE)
 	@$(GDB) $(GDB_FLAGS) -ex 'file $<'
 .PHONY: monitor
 
+monitor-real: $(GDB_REALMODE_XML)
+	@\
+	$(GDB) $(GDB_FLAGS) 		\
+	-ex 'set tdesc filename $<'	\
+	-ex 'b *0x7c00'				\
+	-ex 'c'
+
 # unios rules
 include $(PROJMK_PREFIX)rules-gen.mk
 include $(PROJMK_PREFIX)rules-obj.mk
@@ -62,10 +69,10 @@ install:
 
 # compile_commands.json rules
 $(OBJDIR)/compile_commands.json: force
-	@echo -ne "[PROC] dump compile_commands.json\r"
+	@echo -ne "[PROC] dump $(notdir $@)\r"
 	@mkdir -p $(@D)
-	@bear --output $(OBJDIR)/compile_commands.json -- $(MAKE) -B > /dev/null 2>&1
-	@echo -e "\e[1K\r\e[32m[DONE]\e[0m dump compile_commands.json"
+	@bear --output $@ -- $(MAKE) -B > /dev/null 2>&1
+	@echo -e "\e[1K\r\e[32m[DONE]\e[0m dump $(notdir $@)"
 .PHONY: force
 
 dup-cc: $(OBJDIR)/compile_commands.json
-- 
2.34.1

