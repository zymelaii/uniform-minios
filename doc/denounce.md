
æ„Ÿè°¢ GOOD çš„ miniosï¼Œè®©æˆ‘ä¸€å¤©é«˜è¡€å‹ $\infty$ æ¬¡ã€‚

ä¸ºäº†æ–¹ä¾¿åäººæ›´å®¹æ˜“æ¥è§¦åˆ°é«˜è¡€å‹çš„çœŸç›¸ï¼Œæˆ‘åœ¨è¿™é‡Œæå‡ºå¼ºçƒˆè°´è´£çš„æ¸…å•ï¼

# ç¥ä¹å…¶ç¥çš„ä¼ å‚ä¸ç¡¬ç¼–ç å®ç°

> from kernel/ktest.c:untar

```c
static void untar(const char *filename) {
    ...
    int fd = do_vopen(filename, O_RDWR);
    ...
    while (1) {
        ...
        char full_name[30] = "/orange/";
        strcat(full_name, phdr->name);
        int fdout = do_vopen(full_name, O_CREAT | O_RDWR);
        ...
    }
    ...
}
```

æˆ‘å°±æ˜¯è¯´æ‚¨è€äººå®¶è·¯å¾„éƒ½ä¼ å‚äº†æ‚¨å°±éå¾—åœ¨å®ç°é‡Œå†ç¡¬ç¼–ç ä¸€éå—ï¼Ÿæ‚¨è¦æ˜¯ä¼ å‚çš„æ˜¯ç›¸å¯¹è·¯å¾„å°±ç®—äº†ï¼Œç»“æœæç€ä¼ ç»å¯¹è·¯å¾„å‘¢ï¼Ÿä¼ ç»å¯¹è·¯å¾„å°±ç®—äº†ï¼Œèƒ½ä¸èƒ½åœ¨å®ç°é‡Œå°Šé‡ä¸€ä¸‹ä¼ å‚ï¼Œå°±éå¾—ç¡¬ç¼–ç ä¸€ä¸‹å—ï¼Ÿä¼ ç»å¯¹è·¯å¾„ä½œä¸ºå‚æ•°çš„æ„ä¹‰åœ¨å“ªï¼Ÿå½“ä½œ BUG çš„å‚¬åŒ–å‰‚å—ï¼Ÿ

ç”šè‡³è¿˜è¦åœ¨ Makefile é‡ŒåŠ å®æ§åˆ¶ä¼ å…¥çš„å‚æ•°æ¥æ„é€ ä¼ å‚çš„ç»å¯¹è·¯å¾„ã€‚ä½ éƒ½çŸ¥é“ç”¨å®å’Œä¼ å‚æ¥æ§åˆ¶ untar çš„æ–‡ä»¶äº†ç»“æœåœ¨å®ç°é‡Œæ•´è¿™ä¹ˆä¸€æ‰‹ï¼Œæ˜¯è§‰å¾—å¥½ç©å—ï¼Ÿæ˜¯è§‰å¾—æŠŠå¤©ä¸Šå®«é˜™å’Œåœ°ä¸Šçš„å±æ··åœ¨ä¸€èµ·å¾ˆæœ‰è‰ºæœ¯æ„Ÿå—ï¼Ÿ

# åªè¯»ï¼Ÿåˆè¯»åˆå†™ï¼Œæš—åº¦é™ˆä»“ï¼

> from kernel/vfs.c:get_index

```c
static int get_index(char path[]) {
    int  pathlen = strlen(path);
    char fs_name[DEV_NAME_LEN];
    int  len = (pathlen < DEV_NAME_LEN) ? pathlen : DEV_NAME_LEN;
    int  i, a = 0;
    for (i = 0; i < len; i++) {
        if (path[i] == '/') {
            a = i;
            a++;
            break;
        } else {
            fs_name[i] = path[i];
        }
    }
    fs_name[i] = '\0';
    for (i = 0; i < pathlen - a; i++) path[i] = path[i + a];
    path[pathlen - a] = '\0';
    for (i = 0; i < NR_FS; i++) {
        if (vfs_table[i].fs_name == NULL) continue;
        if (!strcmp(fs_name, vfs_table[i].fs_name)) return i;
    }
    return -1;
}
```

å“ˆï¼Œè¿™ä¸ªå‡½æ•°å¹²äº†ä»€ä¹ˆäº‹å‘¢ï¼Ÿget_indexï¼Œè·å– path å¯¹åº”çš„è®¾å¤‡ç´¢å¼•ï¼Œéå¸¸æ­£ç¡®ï¼ä½†æ˜¯æ˜¯ä¸æ˜¯ä»£ç å¤ªå¤šä¸”å¤ªä¹±äº†ï¼Ÿ

å¥½ï¼Œå…ˆçœ‹å‰ä¸€åŠï¼Œå¾—äº†æˆ‘çŸ¥é“ä½ æƒ³æ‹·è´ç¬¬ä¸€ä¸ª "/" ä¹‹å‰çš„å†…å®¹ç”¨æ¥æå–è®¾å¤‡åï¼Œç„¶ååœ¨ table ä¸­é€ä¸ªæ¯”è¾ƒï¼Œå¾—åˆ° indexã€‚å¾ˆå¥½ï¼Œå¾ˆæ­£å¸¸ï¼Œè™½ç„¶å†™çš„å¾ˆçƒ‚ä½†æ˜¯å¯ä»¥å®¹å¿ã€‚

ä½†æ˜¯ä½ è¿™æ˜¯ä»€ä¹ˆç©æ„ `for (i = 0; i < pathlen - a; i++) path[i] = path[i + a];`ï¼ŒMDï¼Œæ”¹æˆ‘å®å‚æ˜¯å§ï¼Ÿä½ ä¸€ä¸ª get ç³»æ–¹æ³•ç»™æˆ‘æ¥ä¸€ä¸ª inout å‹å‚æ•°è€Œä¸”ä¸€ç‚¹è¯´æ˜éƒ½æ²¡æœ‰ï¼Ÿæ˜¯è§‰å¾—ä¼ å‚ä¸åŠ  const å·²ç»æ˜¯å¤©å¤§çš„æš—ç¤ºäº†å—ï¼Ÿæˆ‘çœŸ \*\*\*\*\*ã€‚

æ¥çœ‹çœ‹è°ƒç”¨å¤„æ˜¯æ€ä¹ˆå†™çš„ï¼š

```c
int pathlen = strlen(path);
char pathname[PATH_MAX];
strcpy(pathname,(char *)path);
pathname[pathlen] = 0;

int index = get_index(pathname);
if (index == -1) { return -1; }
int fd = vfs_table[index].op->open(pathname, flags);
```

ä¹ä¸€çœ‹ï¼Œå‰é¢å¯¹ path çš„æ‹·è´æ˜¾å¾—å¾ˆ**å®‰å…¨**ï¼Œçœ‹ä¼¼å¤šä½™ä½†å¯ä»¥ç†è§£ã€‚ç„¶åå†å¾€åçœ‹ä½ å°±ä¼šå‘ç°è‡ªå·±æƒ³é”™äº†â€”â€”å‘µå‘µï¼Œè¿™æ‹·è´è¿˜çœŸæ˜¯ä¸€ç‚¹éƒ½ä¸å¤šä½™ï¼Œå®Œå–„çš„è®©äººæƒ³åã€‚

ç»“åˆä¸€ä¸‹ get_index çš„å®ç°ï¼Œget_index ä¸å°±æ˜¯å®Œæˆäº†**æå–è®¾å¤‡åç§°ä¸”åŒ¹é…è®¾å¤‡ç´¢å¼•å¹¶å°†ä¼ å‚çš„ç»å¯¹è·¯å¾„è½¬æ¢ä¸ºç›¸å¯¹äºè®¾å¤‡åçš„ç›¸å¯¹è·¯å¾„**å—ï¼Ÿï¼å¾ˆæ­£å¸¸çš„å®ç°ï¼Œä½†æ˜¯ä½ æœ‰æ²¡æœ‰æƒ³è¿‡å°†è¿™ç§æ“ä½œæè¿°ä¸º get_index å ªç§°æè‡´çš„è¯¯å¯¼å•Šï¼ï¼

é¢å¤–å†™ä¸€ä¸ªè½¬æ¢ç›¸å¯¹è·¯å¾„çš„æ–¹æ³•éš¾é“å¾ˆéš¾å—ï¼Ÿæ˜æ˜å°±æ˜¯ç”šè‡³éƒ½ä¸éœ€è¦æ‹·è´ç›´æ¥å°†ç»å¯¹è·¯å¾„åç§» `strlen(devname)+1` å°±è¡Œäº†å•Šï¼

# å°çŒ«æ˜¯çŒ«ï¼Œç†ŠçŒ«ä¹Ÿæ˜¯çŒ«ï¼Œæˆ‘ä»¬éƒ½æ˜¯å¥½çŒ«

> from kernel/vfs.c:do_vcreatedir

```c
int do_vcreatedir(char *path) {
    int  state;
    int  pathlen = strlen(path);
    char pathname[PATH_MAX];
    strcpy(pathname, path);
    pathname[pathlen] = 0;

    int index;
    index = (int)(pathname[1] - '0');
    for (int j = 0; j <= pathlen - 3; j++) { pathname[j] = pathname[j + 3]; }

    state = f_op_table[index].createdir(pathname);
    if (state != OK) { DisErrorInfo(state); }
    return state;
}
```

`index = (int)(pathname[1] - '0')`ï¼Ÿä½ ç¤¼è²Œå—ï¼Ÿä½ çš„ path æ˜¯é‡‘å±‹å—ï¼Ÿæ˜¯è—äº†å¨‡å—è¿™ä¹ˆç‰›é€¼ï¼Ÿä¸Šæ¥ä¸ç®¡ä¸‰ä¸ƒäºŒåä¸€åæ­£ç¬¬äºŒä¸ªå­—ç¬¦åç§» ASCII 0 å°±æ˜¯è®¾å¤‡çš„ç´¢å¼•äº†ï¼Ÿé‚£ä½ è¿™ fs çš„è®¾è®¡æ˜¯å¾—å¤šä¸¥æ ¼ï¼Œå¤šç‰›é€¼å•Šï¼Ÿ

ç”šè‡³è¿˜ä¸å¿˜åƒ get_index é‡Œé‚£æ ·æ‹¿äº†ç´¢å¼•ä¹‹åæŠŠè·¯å¾„è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„ï¼Œä½ æ˜¯æƒ³å‘Šè¯‰æˆ‘ä½ æ˜¯å¡”ç½—ç‰Œå¤§å¸ˆæ—©åœ¨è®¾è®¡ä¹‹æ—¶å°±å·²ç»é¢„è¨€åˆ° path çš„å‰ç¼€ä¸€å®šæ˜¯ {"/0/", "/1/", "/2/", "/3/", "/4/", "/5/", "/6/", "/7/", "/8/", "/9/"} ä¹‹ä¸€å—ï¼Ÿ

è¿™ä¹ˆç‰›é€¼å•Šï¼Ÿé‚£ä½ èƒ½å¸®æˆ‘ç®—ç®—æˆ‘è¦æ˜¯ä¼ å…¥ä¸€ä¸ª "/orange/" è¿™ä¸ªæ–¹æ³•ä¼šæ€ä¹ˆæ ·å—ï¼Ÿ

å“¦å¯¹äº†æé†’ä¸€ä¸‹ï¼Œf_op_table çš„å¤§å°ä¸è¿‡ä¹Ÿå°± 3 å“¦ï¼Œæ‰€ä»¥ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ

æ˜¯æ•°ç»„è¶Šç•Œï¼Œæ˜¯å¤§æ¦‚ç‡çš„ Segment Fault å•Šï¼ï¼

å€’æ˜¯çœ‹çœ‹åŒèƒæ–¹æ³•éƒ½æ˜¯æ€ä¹ˆå†™çš„ï¼š

```c
int do_vdelete(char *path) {
    int pathlen = strlen(path);
    char pathname[PATH_MAX];
    strcpy(pathname,path);
    pathname[pathlen] = 0;
    int index;
    index = get_index(pathname);
    if (index == -1){ return -1; }
    return vfs_table[index].op->delete(pathname);
}
```

äººå®¶éƒ½æ˜¯è€è€å®å®åœ°é€šè¿‡ get_index ä» vfs_table åŒ¹é…ç´¢å¼•ï¼Œæ€ä¹ˆåˆ°ä½ è¿™é‡Œå°±è¿™ä¹ˆç²—æš´äº†å‘¢ï¼Ÿæ˜¯è°ç»™ä½ çš„å‹‡æ°”ï¼Ÿæ¢é™èŒ¹å—ï¼Ÿ

å°±æ˜¯è¯´å°±ç®—è¿™æ˜¯ä½ ç¥ä¹å…¶ç¥çš„è®¾è®¡èƒ½ä¸èƒ½æ¥ä¸ªæœ‰ç‚¹ç”¨çš„æ³¨é‡Šæˆ–æ–‡æ¡£è€Œä¸æ˜¯ä»£ç é‡Œ `added by` `modified by` `deleted by` æ»¡å¤©é£ï¼Ÿï¼

# è¿‡ç¨‹é”™åˆæ€ä¹ˆæ ·ï¼Ÿæˆ‘ç»“æœä¸æ˜¯å¯¹äº†å—ï¼Ÿä½ å‡­ä»€ä¹ˆè¯´æˆ‘ï¼

> from *.h *.c

æˆ‘èƒ½ç†è§£åœ¨ VSCode é‡Œç»™è¿™ç§å¤è€çš„ Makefile é¡¹ç›®é…ç½® linter ä¸æ˜¯ä¸€ä»¶æ‰‹åˆ°æ“’æ¥çš„äº‹ã€‚

æˆ‘ä¹Ÿèƒ½ç†è§£ä»£ç ç»æ‰‹ä¸€ä¼¯ä¸‡ä¸ªäººé£æ ¼éš¾å…ä¸ç»Ÿä¸€ã€‚

ä½†æ˜¯è¯·é—®æ‚¨èƒ½ä¸èƒ½ç¨å¾®æ³¨æ„ä¸€ä¸‹å¼•ç”¨çš„ä¾èµ–å…³ç³»é—®é¢˜ï¼Ÿ

ä½ è¯´ make èƒ½ç›´æ¥ç¼–è¯‘é€šè¿‡ï¼Œç¡®å®ï¼Œæ˜¯çœŸçš„ã€‚

ä½†æ˜¯å°±å¥½æ¯”ä½ è¿™ proc.h é‡Œæ ¹æœ¬å°±æ²¡åŒ…å« protect.h å´æ­£å¸¸åœ°ä½¿ç”¨äº†åªåœ¨ protect.h é‡Œå£°æ˜çš„ typedefï¼Œç¨å¾®è®¤è¯†åˆ°ç¼–è¯‘å™¨ä¸æ˜¯ä¸‡èƒ½çš„åº”è¯¥å°±èƒ½å‘ç°å®ƒä¸å¯èƒ½ç»™ä½ è™šç©ºå¼•å…¥ç¬¦å·å§ï¼Ÿ

æ‰€ä»¥ä½ è¯´ä½ è¿™ç¼–è¯‘ä¸ºä»€ä¹ˆèƒ½é€šè¿‡ï¼Ÿæ˜¯ TM å› ä¸ºä½ æ¯ä¸ªåŒ…å« proc.h çš„æºæ–‡ä»¶é‡Œåœ¨åŒ…å« proc.h ä¹‹å‰éƒ½ç›´æ¥æˆ–é—´æ¥åœ°åŒ…å«äº† protect.h å•Šï¼ä½ è¯´å®ƒæ—¢ç„¶éƒ½å…œäº†å±±è·¯åå…«å¼¯å¥½ä¸å®¹æ˜“å¼•å…¥äº†å®ƒèƒ½ä¸é€šè¿‡å—ï¼Ÿæ‹œæ‰˜ï¼Œæ‚¨èƒ½é€šè¿‡ç¼–è¯‘å¤§æ¦‚ç‡æ˜¯é è¿æ°”å•Šï¼Œæ˜¯é ä¸Šå¤©çœ·é¡¾å•Šï¼

æˆ‘ä¸ºäº†æ¶ˆé™¤ warning å¯æ˜¯æŠŠæ‰€æœ‰ *.c *.h éƒ½ç»™æ”¹äº†å•Šï¼è¿™æ„æ€æ˜¯æ²¡æœ‰ä¸€ä¸ªæ–‡ä»¶èƒ½ç‹¬ç«‹åœ°æ— ä¼¤è¿‡ linter å•Šï¼

å†è€…å°±æ˜¯å°æä¸€å˜´é‚£è¯¸å¤©ç¥ä½›éƒ½ç•æƒ§çš„æ··æ²Œä¾èµ–å…³ç³»ã€‚å°½ç®¡æŠŠæœ€å¤šçš„å¼•ç”¨éƒ½æ”¾åˆ°äº†æºæ–‡ä»¶ï¼Œä½†è¿˜æ˜¯ä¸å¯é¿å…åœ°å‡ºç°äº†å¾ªç¯ä¾èµ–ï¼Œæœ€ç»ˆè¿˜æ˜¯ä¸å¾—ä¸ç”¨å‰ç½®å£°æ˜æ¥è§£å†³é—®é¢˜ã€‚

å²‚å¯ä¿®ï¼

# çŒ´å­æ°è‹è°·

> from kernel/exec.c:sys_exec

```c
for (ph_num = 0; ph_num < Echo_Ehdr->e_phnum; ph_num++) {
    if (0 == Echo_Phdr[ph_num].p_memsz) { break; }
    if (Echo_Phdr[ph_num].p_flags
        & 0x1) // xx1ï¼Œ__E, executable seg must be code seg
    {          //.text
        exec_elfcpy(fd, Echo_Phdr[ph_num], PG_P | PG_USU | PG_RWR);
        p_proc_current->task.memmap.text_lin_base = Echo_Phdr[ph_num].p_vaddr;
        p_proc_current->task.memmap.text_lin_limit =
            Echo_Phdr[ph_num].p_vaddr + Echo_Phdr[ph_num].p_memsz;
    } else if (Echo_Phdr[ph_num].p_flags & 0x4) {
        exec_elfcpy(fd, Echo_Phdr[ph_num], PG_P | PG_USU | PG_RWW);
        p_proc_current->task.memmap.data_lin_base = Echo_Phdr[ph_num].p_vaddr;
        p_proc_current->task.memmap.data_lin_limit =
            Echo_Phdr[ph_num].p_vaddr + Echo_Phdr[ph_num].p_memsz;
    } else {
        vga_write_str_color("exec_load: unKnown elf'program!", 0x74);
        return -1;
    }
}
```

ä¸€ä¸ª elf æ‰§è¡Œçš„æ—¶å€™åŠ è½½ä¸‰å››ä¸ª LOAD æ®µï¼Œä½ è®°å½•åŠ è½½æ®µçš„åœ°å€ä¸Šä¸‹ç•Œé™çš„æ—¶å€™åŠ è½½ä¸€ä¸ª LOAD æ”¹ä¸€æ¬¡ï¼Œç­‰æ‰€æœ‰ LOAD åŠ è½½å®Œäº†å‘ç°ç¬¬ä¸€ä¸ª LOAD æ®µçš„åœ°å€ä¸Šä¸‹é™å·²ç»è¢«æœ€åä¸€ä¸ª LOAD æ®µç»™æ”¹å®Œäº†ï¼Œå¥½å®¶ä¼™å¥½å®¶ä¼™ï¼Œæ€ªä¸å¾—æ¯æ¬¡ fork éƒ½ä¼šä¸¢ data æ®µï¼ŒåŸæ¥çˆ¶è¿›ç¨‹åªä¿è¯äº†è‡ªå·±æ˜¯å¯¹çš„ï¼Œè‡ªå·±çš„ pcb å‹æ ¹éƒ½æ²¡æœ‰è®°å½•å…¨éƒ¨çš„ LOAD æ®µä¿¡æ¯ï¼Œè¿™è®©é‡Šæ”¾çš„æ—¶å€™æ€ä¹ˆé‡Šæ”¾ï¼Ÿå­è¿›ç¨‹å¦‚ä½• forkï¼Œæˆ‘çš„è¯„ä»·æ˜¯ fork ä¸äº†ä¸€ç‚¹ã€‚

å‡è®¾æˆ‘ä»¬çš„ ph æ®µåªæœ‰ä¸¤ä¸ª LOADï¼Œå¥½ï¼Œå¾ˆå®Œç¾ï¼Œéƒ½åŠ è½½äº†ï¼Œfork ä¹Ÿæ­£å¸¸ã€‚ä½†å¦‚æœæœ‰ä¸‰ä¸ªï¼Œç¬¬ä¸‰æ¬¡å¾ªç¯çš„æ—¶å€™è¦ä¹ˆæŠŠ text_lin_base è¦†ç›–æ‰ï¼Œè¦ä¹ˆæŠŠ data_lin_base å’Œ data_lin_limit è¦†ç›–æ‰ã€‚

è¿™ä¸å°±çŒ´å­æ°è‹è°·ï¼Œæ”¹ä¸€ç‚¹ä¸¢ä¸€ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚åä¸‰ç‚¹ã€‚

# è¿™æ®µè¦åè½¬ä¸€ä¸‹ï¼ä½ è¯´çš„å¯¹ï¼Œä½†æ˜¯

> from kernel/fork.c:fork_mem_copy

```c
// å¤åˆ¶æ ˆï¼Œæ ˆä¸å…±äº«ï¼Œå­è¿›ç¨‹éœ€è¦ç”³è¯·ç‰©ç†åœ°å€ï¼Œå¹¶å¤åˆ¶è¿‡æ¥(æ³¨æ„æ ˆçš„å¤åˆ¶æ–¹å‘)
for (addr_lin = p_proc_current->task.memmap.stack_lin_base;
        addr_lin > p_proc_current->task.memmap.stack_lin_limit;
        addr_lin -= num_4K) {
    lin_mapping_phy(
        SharePageBase,
        0,
        ppid,
        PG_P | PG_USU | PG_RWW,
        0); // ä½¿ç”¨å‰å¿…é¡»æ¸…é™¤è¿™ä¸ªç‰©ç†é¡µæ˜ å°„
    lin_mapping_phy(
        SharePageBase,
        MAX_UNSIGNED_INT,
        ppid,
        PG_P | PG_USU | PG_RWW,
        PG_P | PG_USU | PG_RWW); // åˆ©ç”¨çˆ¶è¿›ç¨‹çš„å…±äº«é¡µç”³è¯·ç‰©ç†é¡µ
    memcpy(
        (void*)SharePageBase,
        (void*)(addr_lin & 0xFFFFF000),
        num_4K); // å°†æ•°æ®å¤åˆ¶åˆ°ç‰©ç†é¡µä¸Š,æ³¨æ„è¿™ä¸ªåœ°æ–¹æ˜¯å¼ºåˆ¶ä¸€é¡µä¸€é¡µå¤åˆ¶çš„
    lin_mapping_phy(
        addr_lin, // çº¿æ€§åœ°å€
        get_page_phy_addr(
            ppid,
            SharePageBase), // ç‰©ç†åœ°å€ï¼Œè·å–å…±äº«é¡µçš„ç‰©ç†åœ°å€ï¼Œå¡«è¿›å­è¿›ç¨‹é¡µè¡¨
        pid, // è¦æŒ‚è½½çš„è¿›ç¨‹çš„pidï¼Œå­è¿›ç¨‹çš„pid
        PG_P | PG_USU | PG_RWW,  // é¡µç›®å½•å±æ€§ï¼Œä¸€èˆ¬éƒ½ä¸ºå¯è¯»å†™
        PG_P | PG_USU | PG_RWW); // é¡µè¡¨å±æ€§ï¼Œæ ˆæ˜¯å¯è¯»å†™çš„
}
```

è¡Œè¡Œè¡Œæˆ‘çŸ¥é“æ ˆæ˜¯å‘ä½åœ°å€ç”Ÿé•¿çš„ä¹Ÿçœ‹åˆ°ä½ çš„ `addr_lin -= num_4K` äº†ã€‚

ä½†æ˜¯ï¼Œå°±æ˜¯è¯´ï¼Œä½ æ™“ä¸æ™“å¾— memcpy æ˜¯ä»ä½åœ°å€å‘é«˜åœ°å€æ‹·è´çš„ï¼Ÿ

ä½ è¿™æ˜¯ clone æ ˆåŒº \[stack_lin_limit, stack_lin_base) å—ï¼Ÿä½ è¿™ä¸åˆ†æ˜åœ¨ clone (stack_lin_limit+4K, stack_lin_base+4K] å—ï¼Ÿï¼åˆç¼ºæ–¤çŸ­ä¸¤åˆé…’é‡Œæºæ°´äº†å•Šå–‚ï¼

# ä½ ä¸æ‡‚ï¼Œç³Šå¼„åŒäº‹æœ‰åŠ©äºæ¶¨ä¸šç»©ï¼

> from kernel/pagetbl.c:vmalloc

```c
u32 vmalloc(u32 size) {
    u32 temp;
    if (p_proc_current->task.info.type == TYPE_PROCESS) { // è¿›ç¨‹ç›´æ¥å°±æ˜¯æ ‡è¯†
        temp = p_proc_current->task.memmap.heap_lin_limit;
        p_proc_current->task.memmap.heap_lin_limit += size;
    } else { // çº¿ç¨‹éœ€è¦å–çˆ¶è¿›ç¨‹çš„æ ‡è¯†
        temp = *((u32 *)p_proc_current->task.memmap.heap_lin_limit);
        (*((u32 *)p_proc_current->task.memmap.heap_lin_limit)) += size;
    }
    return temp;
}
```

å·²çŸ¥ heap_lin_limit çš„ç±»å‹æ˜¯ u32ï¼Œå¹¶ä¸” thread çš„ head æ˜¯æŒ‡å‘çˆ¶è¿›ç¨‹/ä¸»çº¿ç¨‹çš„ head ptrã€‚

> å­çº¿ç¨‹ä¸ä¸»çº¿ç¨‹å…±ç”¨å †ï¼Œä½†æ˜¯å˜é‡ç‹¬ç«‹ã€‚ä¸ºäº†ç»´æŠ¤å †ï¼Œåœ¨æ­¤å®ç°ä¸­å­çº¿ç¨‹é€šè¿‡æŒ‡å‘ä¸»çº¿ç¨‹ heap limit çš„æŒ‡é’ˆå®ŒæˆåŒæ­¥ã€‚

ä½ è‡ªå·±ç…ç…ï¼Œä½ å†™çš„æ˜¯äººè¯å—ï¼Ÿ

åŠ è¿™ä¹ˆç‚¹ç ´çƒ‚æ·»å¤´ä½ æœ‰å·¥èµ„æ‹¿å—ï¼Ÿ

é™¤äº†æ¶å¿ƒè‡ªå·±æ¶å¿ƒåˆ«äººè¿˜æœ‰ä»€ä¹ˆå±ç”¨å—ï¼Ÿ

æˆ‘ä¸è‹›æ±‚ä½ æŠŠç»“æ„æ”¹è‰¯ï¼Œä½ ç›´æ¥æŠŠæ³¨é‡Šåˆ äº†ä¸è¡Œå—ï¼Ÿè¿˜`éœ€è¦è·å–çˆ¶è¿›ç¨‹çš„æ ‡è¯†`â€¦â€¦

ä½ è¿™è·å–çš„æ˜¯çˆ¶è¿›ç¨‹çš„æ ‡è¯†å—ï¼Ÿï¼éš¾é“ä½ è‡ªå·±éƒ½ä¸æ¸…æ¥šè‡ªä¸ªå„¿æ˜¯æ€ä¹ˆå®ç°çˆ¶å­çº¿ç¨‹çš„å †å…±äº«çš„å—ï¼Ÿä½ éœ€è¦æ³¨é‡Šçš„æ˜¯`è¿™ä¸ª limit å…¶å®æ˜¯æŒ‡å‘ä¸»çº¿ç¨‹ heap limit çš„æŒ‡é’ˆ`è€Œä¸æ˜¯`è·å–çˆ¶è¿›ç¨‹çš„æ ‡è¯†`å•Šï¼

# é¡µé¢æ˜¯ 4K å¯¹é½çš„ï¼æ‰€ä»¥æ•´é¡µæ•´é¡µæ‹·è´å°±è¡Œäº†

> from kernel/fork.c:fork_mem_copy

```c
for (addr_lin = p_proc_current->task.memmap.stack_lin_base;
        addr_lin > p_proc_current->task.memmap.stack_lin_limit;
        addr_lin -= num_4K) {
    lin_mapping_phy(
        SharePageBase,
        0,
        ppid,
        PG_P | PG_USU | PG_RWW,
        0); // ä½¿ç”¨å‰å¿…é¡»æ¸…é™¤è¿™ä¸ªç‰©ç†é¡µæ˜ å°„
    lin_mapping_phy(
        SharePageBase,
        MAX_UNSIGNED_INT,
        ppid,
        PG_P | PG_USU | PG_RWW,
        PG_P | PG_USU | PG_RWW); // åˆ©ç”¨çˆ¶è¿›ç¨‹çš„å…±äº«é¡µç”³è¯·ç‰©ç†é¡µ
    memcpy(
        (void*)SharePageBase,
        (void*)(addr_lin & 0xFFFFF000),
        num_4K); // å°†æ•°æ®å¤åˆ¶åˆ°ç‰©ç†é¡µä¸Š,æ³¨æ„è¿™ä¸ªåœ°æ–¹æ˜¯å¼ºåˆ¶ä¸€é¡µä¸€é¡µå¤åˆ¶çš„
    lin_mapping_phy(
        addr_lin, // çº¿æ€§åœ°å€
        get_page_phy_addr(
            ppid,
            SharePageBase), // ç‰©ç†åœ°å€ï¼Œè·å–å…±äº«é¡µçš„ç‰©ç†åœ°å€ï¼Œå¡«è¿›å­è¿›ç¨‹é¡µè¡¨
        pid, // è¦æŒ‚è½½çš„è¿›ç¨‹çš„pidï¼Œå­è¿›ç¨‹çš„pid
        PG_P | PG_USU | PG_RWW,  // é¡µç›®å½•å±æ€§ï¼Œä¸€èˆ¬éƒ½ä¸ºå¯è¯»å†™
        PG_P | PG_USU | PG_RWW); // é¡µè¡¨å±æ€§ï¼Œæ ˆæ˜¯å¯è¯»å†™çš„
}
```

æ‰¿æ¥ä¸Šæ–‡**è¿™æ®µè¦åè½¬ä¸€ä¸‹ï¼ä½ è¯´çš„å¯¹ï¼Œä½†æ˜¯**ï¼Œfork_mem_copy åœ¨ç»å†åƒé”¤ç™¾ç‚¼ä¹‹åå†æ¬¡åœ¨å¸Œæœ›çš„ç»ˆç‚¹ç»™äºˆæˆ‘ä»¬èƒŒåˆºï¼

ç®€å•ä¿®å¤å‰æ–‡ä¸­æ‰€æçš„æ–¹å‘çš„é—®é¢˜ï¼Œå¯ä»¥å°†ä»£ç ä¿®æ”¹å¦‚ä¸‹ï¼š

```c
for (addr_lin = p_proc_current->task.memmap.stack_lin_limit;
     addr_lin < p_proc_current->task.memmap.stack_lin_base;
     addr_lin += num_4K) {
    lin_mapping_phy(SharePageBase, 0, ppid, PG_P | PG_USU | PG_RWW, 0);
    lin_mapping_phy(
        SharePageBase,
        MAX_UNSIGNED_INT,
        ppid,
        PG_P | PG_USU | PG_RWW,
        PG_P | PG_USU | PG_RWW);
    memcpy((void*)SharePageBase, (void*)(addr_lin & 0xFFFFF000), num_4K);
    lin_mapping_phy(
        addr_lin,
        get_page_phy_addr(ppid, SharePageBase),
        pid,
        PG_P | PG_USU | PG_RWW,
        PG_P | PG_USU | PG_RWW);
}
```

å¾ˆå¯¹å§ï¼

çœ‹ä¸Šå»ç¡®å®å¾ˆå¯¹ï¼Œæ ˆçš„é—®é¢˜ä¿®å¤äº†ï¼Œå¯èƒ½ä¼šé”™çš„åœ°æ–¹ä¹Ÿæ³¨æ„åˆ°äº†ã€‚

ä½†æ˜¯å¥½äº†å˜›ï¼ï¼Ÿ

å¤§æŠµç¡®å®æ˜¯å¥½äº†å§ï¼Œæ¯•ç«Ÿæ•´ä¸ªä»£ç é‡Œå¾ˆå¤šå…¶å®ƒç±»ä¼¼çš„åœ°æ–¹ä¹Ÿæ˜¯è¿™ä¹ˆå¹²çš„ï¼Œä¸ä¹Ÿæ˜¯æ­£å¸¸çš„è·‘äº†å—ï¼Ÿå†è¯´äº†ï¼Œæ—¢ç„¶åŸæ¥åç§»äº† 0x1000 çš„ä»£ç èƒ½æ­£å¸¸è·‘ï¼Œé‚£æˆ‘åªè¦æŠŠæ‰€æœ‰è·Ÿ stack addr æœ‰å…³çš„åœ°æ–¹å…¨éƒ¨æŠŠ 0x1000 åç§»çš„é—®é¢˜ä¿®å¤äº†ï¼Œ~~æ ¹æ®å¹³ç§»ä¸å˜æ€§~~é‚£ä¸å°±æ˜¯å¾ˆæ˜¾ç„¶åœ°ä¹Ÿèƒ½æ­£å¸¸è¿è¡Œå—ï¼Ÿï¼

åŸç¥ï¼Œå¯åŠ¨ï¼ï¼

> å®ï¼ä½ æ”¶è·äº†ä¸€ä¸ª page faultï¼

ä¸å¯èƒ½ï¼Œè¿™ç»å¯¹ä¸å¯èƒ½ï¼ï¼ï¼ç®€å•æŸ¥ä¸‹ stack limit çš„ pteâ€”â€”æ²¡é”™å•Šï¼Œè¿™ä¸æ˜¯å­˜åœ¨å—ï¼Ÿï¼å±æ€§å€¼ä¸éƒ½å¯¹ç€å—ï¼Ÿï¼

â€¦â€¦

â€¦â€¦

â€¦â€¦

å±®ï¼Œstack base çš„ pte æ€ä¹ˆæ²¡æœ‰ï¼Ÿï¼å¾€å‰ 4Bï¼Œä¹Ÿæ²¡æœ‰ï¼å¾€å‰ 0x1000ï¼Œå¥½ï¼Œå­˜åœ¨ï¼ï¼â€”â€”MDï¼Œå°‘æ‹·è´ä¸€é¡µï¼

å†å›è¿‡æ¥çœ‹ä»£ç â€”â€”ä¸å¯¹ï¼Œæ˜¯å…ˆçœ‹çœ‹ stack çš„ base å’Œ limitã€‚æ›¾ç»å¾ˆå¶ç„¶åœ°ç¥åˆ°äº† `#define StackLinBase (ArgLinBase - num_4B)`ï¼Œå½“æ—¶åªé“æ˜¯è«åå…¶å¦™ï¼Œä½†åˆé“æ— ä¼¤å¤§é›…ï¼Œå¹¶ä¸ä¼šå½±å“åˆ°ä»£ç çš„æ‰§è¡Œã€‚å¯ç°ä»Šä¸€çœ‹ï¼Œå¦‚ä½•ä¸èƒ½ï¼

å½“ä¸‡åƒé”™è¯¯é›†ç»“åˆ°ä¸€èµ·æ±‡èšå‡ºä¸€ä¸ª**æ°å·§**èƒ½å¤Ÿæ­£å¸¸è¿è¡Œçš„ä»£ç ï¼Œé‚£ä¿®å¤ä»–éƒ½æ˜¯ä¸€ç§è«å¤§çš„ç½ªè¿‡ï¼

åœ¨å…¶å®ƒæƒ…å†µä¸‹ï¼Œæˆ‘é‡å†™äº† range mapping çš„æ–¹æ³•ï¼Œå¹¶å……åˆ†å¤„ç†äº†é¡µå¯¹é½çš„é—®é¢˜ï¼Œæ•…è€Œ elf LOAD å€’æ˜¯ååˆ†é¡ºåˆ©åœ°è¿è¡Œäº†ã€‚ä½†åœ¨ vpageã€heapã€argã€stack ç­‰ laddr æ‰‹åŠ¨ç¼–æ’çš„å†…å­˜ç©ºé—´ä¸Šï¼Œåˆ™æ˜¯åœ¨ fork_mem_copy ä¸­åˆ©ç”¨å…±äº«é¡µä¾¿åˆ©åŒ–æ‹·è´å¹¶å°†ç‰©ç†é¡µè½¬ç§»ç»™å­è¿›ç¨‹ã€‚æŒ‰ç†è¯´è¿™äº›ç©æ„åº”è¯¥æ˜¯åŒç”Ÿå…±æ­»çš„ï¼Œå¯ç»†ç»†ä¸€æŸ¥ï¼Œæ€ä¹ˆä¼šåªæœ‰ stack å‡ºé—®é¢˜äº†å‘¢ï¼Ÿ

ä¸€ç…â€”â€”å°±å¥å£®æ€§è€Œè¨€ï¼Œfork_mem_copy ç†æ‰€åº”å½“è¦å¯„ï¼laddr æ•´é¡µé€’å¢ï¼Œé‚£è¦æ˜¯æŠµè¾¾ limit æ—¶ limit æ²¡æœ‰ä¸é¡µé¢å°ºå¯¸å¯¹é½æ€ä¹ˆåŠï¼Ÿé¡µå†…åç§» `0 ~ limit & 0xfff` çš„è¿™ä¸€éƒ¨åˆ†éš¾é“å°±æŠ›å¼ƒå˜›ï¼é‚£å¿…ç„¶è¿˜æ˜¯è¦å†ç”³è¯·ä¸€é¡µçš„ï¼å¦‚æ­¤æƒ…å½¢ä¸å¤„ç†ï¼Œstack ç¼ºé¡µä¸æ˜¯ç†æ‰€åº”å½“ï¼

ä½†ä¸ºä»€ä¹ˆ vpageã€heapã€arg è¿™äº›æ²¡å¯„ï¼Ÿï¼ˆä¸€æ–¹é¢æ˜¯å› ä¸ºè¿™æ—¶å€™å‹æ ¹å°±æ²¡ pteï¼Œæ‰€ä»¥æ€ä¹ˆæƒ³éƒ½å¯„ä¸äº†å•Š~ï¼‰çœ‹çœ‹äººå®¶ï¼Œä»–ä»¬çš„ base å’Œ limit å¯éƒ½æ˜¯ 4K å¯¹é½çš„å•Šï¼base å³æ˜¯é¡µè¾¹ç•Œï¼Œlimit å³æ˜¯æœ€åä¸€é¡µçš„è¾¹ç•Œï¼Œè¿™ä¸€æ¥äºŒå»ï¼Œè¾¹ç•Œå¯¹è¾¹ç•Œï¼Œè‡ªç„¶ä¸ä¼šæœ‰ç¼ºé¡µçš„é—®é¢˜ã€‚æ‰€ä»¥ä»–ä»¬å¯„äº†å—ï¼Ÿ**è¿æ°”å¥½æ²¡å¯„ç½¢äº†ï¼**

å€˜è‹¥ä¸æ˜¯ä¸€æ‰‹ `StackLinBase = ArgLinBase - num_4B` æŠŠ 4K å¯¹é½çš„ç‰¹æ€§æ‰“å¾—ç¨€çƒ‚ï¼Œä¼°è®¡è¿™ç­‰å·®é”™è¿˜è¦å†å»¶åæˆ–è€…åˆ°åº•è¿˜æ˜¯è®©äººå¯Ÿè§‰ä¸äº†â€”â€”æœ‰å¤šå°‘äººä¼šæ–Ÿé…Œä¸€æ®µå®åœ¨ä»¤äººä½œå‘•åˆåˆšå¥½èƒ½å¤Ÿæ­£å¸¸è¿è¡Œçš„ä»£ç å‘¢ï¼Ÿ

å†å»çœ‹çœ‹åç§»äº† 0x1000 çš„æ—§å®ç°ï¼Œé‚£æœçœŸæ²¡é—®é¢˜å—ï¼Ÿ

è‡ªç„¶æ˜¯å·§åˆä¸‹çš„åˆä¸€ä¸ªå·§åˆï¼

**å·§åˆåœ¨ base å¤„å¿…ç„¶ä¼šæœ‰ pteï¼**

**å·§åˆåœ¨ stack çš„å¤§å°è¶³å¤Ÿå¤§ï¼Œç®€å•çš„ç”¨æˆ·ç¨‹åºéš¾ä»¥ä»¤ esp æ¥è¿‘ limit è€Œè§¦å‘ limit å¤„çš„ç¼ºé¡µï¼**

**å·§åˆåœ¨ esp å¹¶éæ˜¯åœ¨çœŸæ­£çš„æ ˆé¡¶ï¼Œè€Œæ˜¯åœ¨è·çœŸæ­£çš„æ ˆé¡¶ 0x1000 å¤„çš„ä½åœ°å€ä½ç½®ï¼**

ä»ä¸€å¼€å§‹å°±æ²¡æœ‰æ­£ç¡®çš„ç®—æ³•å®ç°ï¼

**â€œé¡µé¢æ˜¯ 4K å¯¹é½çš„ï¼æ‰€ä»¥æ•´é¡µæ•´é¡µæ‹·è´å°±è¡Œäº†â€**ï¼Œè¿™å¯¹å—ï¼Ÿè¿™è‡ªç„¶å¯ä»¥æ˜¯å¯¹çš„ï¼Œä½†æ²¡æœ‰æ»¡è¶³è¾¹ç•Œåœ°å€é¡µå¯¹é½ï¼Œåˆè°ˆä½•æ­£ç¡®ï¼ç»ˆç©¶ä¸è¿‡æ˜¯åœ¨ä¸€ç¯å¥—ä¸€ç¯çš„è°¬è¯¯ä¸­è‹Ÿæ´»çš„è™šä¼ª **PASS** ç½¢äº†ï¼

ä¸€æœè´¥éœ²ï¼Œä¾¿å¿˜æ©è´Ÿä¹‰åœ°æ€å¾—äººç‰‡ç”²ä¸ç•™ï¼Œåˆé‡‘è‰è„±å£³äº†å»ï¼

# çº¿æ€§åœ°å€ï¼Ÿç‰©ç†åœ°å€ï¼Ÿèƒ½è·‘å°±è¡Œï¼

> from *.c

```c
buf = (PBYTE)K_PHY2LIN(do_kmalloc(Bytes_Per_Sector * sizeof(BYTE)));
...
do_free(buf);
```

ä»¥åŠé˜Ÿå‹è¢« miniOS å¸¦ååï¼ŒæŒ‰ç…§å…¶å†™æ³•å¢åŠ çš„æ–°åŠŸèƒ½å®ç°ç‰‡æ®µï¼š

```c
Elf32_Ehdr* elf_header = NULL;
Elf32_Phdr* elf_proghs = NULL;
elf_header             = do_kmalloc(sizeof(Elf32_Ehdr));
assert(elf_header != NULL);
read_Ehdr(fd, elf_header, 0);
elf_proghs = do_kmalloc(sizeof(Elf32_Phdr) * elf_header->e_phnum);
assert(elf_proghs != NULL);
for (int i = 0; i < elf_header->e_phnum; i++) {
    u32 offset = elf_header->e_phoff + i * sizeof(Elf32_Phdr);
    read_Phdr(fd, elf_proghs + i, offset);
}

if (exec_load(fd, elf_header, elf_proghs) == -1) {
    do_close(fd);
    do_free(elf_header);
    do_free(elf_proghs);
    return -1;
}
```

> PS: ä»¥ä¸Šå…³ä¹åŸæ±åŸå‘³ miniOS malloc å’Œ free ç”±äºè¿‡äºå¤æ—©ï¼Œå›æº¯è¾ƒä¸ºéº»çƒ¦ï¼Œæ­¤å¤„ä½¿ç”¨ uniform-minios çš„ syscallã€malloc ä¿®æ­£ç‰ˆä½œä¸ºå‚è€ƒä»£ç ï¼Œä½†ä¿è¯è°´è´£ç›®æ ‡ä¾æ—§åŸæ±åŸå‘³ï¼

ä¼—æ‰€å‘¨çŸ¥ï¼Œ`void *ptr = malloc(size); ... free(ptr);` æ˜¯ä¸€ä¸ªå†…å­˜ç®¡ç†çš„èŒƒå¼ã€‚

ä½†æŸä¸ª miniOS æ˜¾ç„¶ä¸æ˜¯è¿™ä¹ˆæƒ³çš„ã€‚

é¦–å…ˆçš„é¦–å…ˆï¼ŒminiOS ç”¨æˆ·æ€çš„ malloc æ˜¯æ²¡ç”¨çš„ï¼Œåªåœ¨å†…æ ¸æ€ä¸‹ä½¿ç”¨ç³»åˆ—æ–¹æ³•è¿›è¡Œå†…å­˜ç®¡ç†ã€‚

> å…³äºç”¨æˆ·æ€çš„ malloc ä¸ºä»€ä¹ˆç”¨ä¸äº†ï¼Œç®€å•ç‚¹æ¥è¯´æ˜¯ heap æ²¡æœ‰æ˜ å°„é¡µé¢ï¼Œä½†è¿™ä¹‹ä¸­æ¶‰åŠåˆ°ä¸€äº›æ›´éœ€è¦è°´è´£çš„æ¶åŠ£æ“ä½œï¼Œæ•…æ­¤å¤„å…ˆä¸æ·±å…¥å±•å¼€ã€‚

ç„¶è€Œè¯´æ˜¯å†…å­˜ç®¡ç†ï¼Œå…¶å®æ­¤ç³»åˆ—æ–¹æ³•å®ç°çš„æ˜¯å¯¹ç‰©ç†åœ°å€åŒºé—´çš„ç®¡ç†ã€‚åªä¸è¿‡ä»°èµ–äºå†…æ ¸é¡µé¢æ€»æ˜¯å¯ç”¨çš„ï¼Œæ•…å¯ä»¥é€šè¿‡ K_PHY2LIN ä»åˆ†é…å¾—åˆ°çš„ç‰©ç†åœ°å€ç›´æ¥è®¿é—®å¯¹åº”çš„å†…æ ¸ç©ºé—´çº¿æ€§åœ°å€ï¼Œç»§è€Œå®Œæˆè®¿å­˜æ“ä½œã€‚

å¥½æˆå°±æ˜¯è¿™ä¹ˆå¼€åœºçš„ã€‚

ç¬¬ä¸€ï¼Œæ­¤ malloc ç³»åˆ—è¿”å›çš„æ˜¯ç‰©ç†åœ°å€ï¼Œåœ¨é¡µè¡¨æœºåˆ¶çš„ä½œç”¨ä¸‹ï¼Œç‰©ç†åœ°å€æ˜¯ä¸èƒ½è¢«è®¿é—®çš„ï¼é™¤éé¡µè¡¨ä¸­æœ‰ä¸è¯¥ç‰©ç†åœ°å€ç­‰å€¼çš„çº¿æ€§åœ°å€æ˜ å°„ã€‚

ç¬¬äºŒï¼Œmalloc å¾—åˆ°çš„æ˜¯ä»€ä¹ˆå°±åº”è¯¥å»é‡Šæ”¾ä»€ä¹ˆã€‚éš¾ä¸æˆä½ æ‰“ç™½æ¡å€Ÿäº†ä¸‰åƒå…ƒè¿˜èƒ½æŠŠè´§å¸å•ä½ä¸€æ”¹ï¼Œæ‰“æ‰®æˆâ€œè¬å…ƒå†¥å¹£â€å†è¿˜å›å»ï¼Ÿæ‚¨è¯´æ‚¨è¿™ç¤¼è²Œå—ï¼Ÿ

å…³äºç¬¬äºŒç‚¹æ— éœ€å¤šè¨€ï¼Œç›´æ¥å‚ç…§æ ·ä¾‹ä»£ç å³å¯æ‚‰çŸ¥ã€‚

é‡ç‚¹æ˜¯ç¬¬ä¸€ä¸ªâ€”â€”å¤©ä½‘æˆ‘ä¹Ÿï¼ï¼å¤©ä½‘æˆ‘ä¹Ÿï¼Ÿï¼

**è¯·çœ‹ç¬¬äºŒæ®µçœ‹ä¸Šå»éå¸¸æ­£ç¡®çš„ä»£ç ã€‚**

å›é¡¾å‰æ–‡ï¼Œåœ¨æ—§çš„å……æ»¡æœªçŸ¥ä¸æŒ‘æˆ˜çš„ç¨€çƒ‚çš„æ ˆé…ç½®ä¸ç»†ç»†å“å°ä¾¿å¯å‘ç°æ¼æ´ç™¾å‡ºçš„é¡µè¡¨å®ç°çš„å…±åŒä½œç”¨ä¸‹â€”â€”è¿™å…¶ä¸­æˆ–è®¸è¿˜æœ‰ä» loader åˆ° kernel_main æ—¶æ¸…é™¤ loader ä½ç«¯é¡µè¡¨é¡µä¸ pcb åˆå§‹åŒ–é¡µè¡¨çš„åŠ©åŠ›â€”â€”è¿™å¯¹ç‰©ç†åœ°å€å ‚è€Œçš‡ä¹‹åœ°è®¿é—®ç«Ÿç„¶å¤§æ‘‡å¤§æ‘†åœ°â€œæ­£å¸¸â€è¿è¡Œäº†å¥½é•¿ä¸€æ®µæ—¶é—´ï¼

æˆ–è®¸æœ‰äººä¼šè¯´ï¼Œè¿™ä¹Ÿä¸æ˜¯ä¸å¯ä»¥å•Šï¼Œæœ‰çº¿æ€§åœ°å€æ˜ å°„ä¸å°±è¡Œäº†ï¼Ÿ

ä½†è¿™æ­£æ˜¯é—®é¢˜æ‰€åœ¨ï¼åœ¨ç°åœ¨çš„å†…å­˜æ¨¡å‹ä¸­ï¼Œè¿™ä¸€æ®µåœ°å€å°±ä¸åº”è¯¥èƒ½å¤Ÿè¢«è¿›ç¨‹åœ¨å†…æ ¸æ€æ­£å¸¸è®¿é—®ï¼é‚£ä¸€äº›æ˜ å°„äº†åœ°å€ 0 çš„ pdeã€pte å‹æ ¹å°±ä¸èƒ½ä¸”ä¸åº”è¯¥å­˜åœ¨ï¼è€Œæ›´è¿‡åˆ†çš„æ˜¯ï¼Œæ­¤å¤„çš„çº¿æ€§åœ°å€ç”šè‡³ä¸æ˜¯æ˜ å°„åˆ°ç­‰å€¼çš„ç‰©ç†åœ°å€ä¸Šçš„ï¼è¿™å°±å‹æ ¹è¿ loader ä¸­é¡µè¡¨æ˜ å°„çš„è¯­ä¹‰éƒ½ä¸æ˜¯ï¼

æ‰€ä»¥æ˜¯ä»€ä¹ˆå¯¼è‡´ä»–ä»¬å­˜æ´»ç€çš„ï¼Ÿ

malloc å®ç°æœ‰è¯¯ï¼Ÿstack å¼•å‘çš„è´è¶æ•ˆåº”ï¼Ÿè¿˜æ˜¯æ•´ä¸ªé¡µè¡¨å®ç°å°±æœ‰è‡´å‘½ç¼ºé™·ï¼Ÿäº¦æˆ–è€…æ˜¯é‚£ kernel main ä¸­æ‰€è°“çš„åˆå§‹åŒ–ä¸æ¸…ç†å·¥ä½œå‹æ ¹å°±æ˜¯è¡¨é¢åŠŸå¤«ï¼Ÿ

åˆæˆ–è€…â€”â€”è°éƒ½æºä¸Šäº†ä¸€è„šï¼Ÿ

æˆ‘æƒ³ä¸æ¸…ï¼Œç©¶ä¸æ˜ã€‚æ‚ä¹±çš„å®ç°ï¼Œå››ä¼çš„éšæ‚£ï¼Œè®©è¿™æ‰€è°“**â€œåªæœ‰å¾ˆå°‘çš„é—®é¢˜â€**çš„ miniOS æ„ˆå‘æ¶å¿ƒã€‚

> â€œã€Šé‡æ„æ˜¯èƒ½å¸¦æ¥å…‰æ˜ï¼Œä½†åªæœ‰é‡å†™æ‰èƒ½çœŸæ­£æ‹¯æ•‘ä¸–ç•Œã€‹â€
>
> â€œæŠŠé¡µè¡¨é‡å†™äº†ï¼Œé‡å†™æ‰æ˜¯æ­£é“å¦ˆçš„ï¼â€

åˆ é™¤ pagetbl.cï¼Œåˆ›å»º page.cï¼Œå°˜åŸƒè½å®šï¼Œæ‰€æœ‰è«åå¥‡å¦™çš„é”™è¯¯é¡¿æ—¶ä¸€æ‰«è€Œç©ºã€‚

è‡³äºæ˜¯ä»€ä¹ˆæœ‰é—®é¢˜ï¼Œè¿™è¿˜éœ€è¦æ›´è¿›ä¸€æ­¥çš„è¯æ˜å—ï¼Ÿ

# é¡µè¡¨ï¼šæ¢…å¼€ä¸‰åº¦ï¼æˆ‘å°±æ˜¯å…¨åœºæœ€é“çš„å´½

> from kernel/console.c:w_copy

```c
static void w_copy(unsigned int dst, const unsigned int src, int size) {
    memcpy(
        (void*)(V_MEM_BASE + (dst << 1)),
        (void*)(V_MEM_BASE + (src << 1)),
        size << 1);
}
```

ç®€è€Œè¨€ä¹‹ï¼Œè¨€è€Œç®€ä¹‹ï¼Œè¿™ä»¶äº‹æˆ‘åªèƒ½è¯´æ‡‚å¾—éƒ½æ‡‚ï¼Œä¸æ‡‚çš„å‘¢ä¹Ÿåˆ«è¶Ÿè¿™è¶Ÿæ··æ°´äº†ï¼Œä¹å‘µä¹å‘µå°±å®Œäº‹äº†ã€‚

**å‰æƒ…æè¦ï¼šé€†å¤©é¡µè¡¨ç‹¬é¢†é£éªš**

åœ¨ä¸€äº›åå«**å¦‚èƒ½è·‘**çš„ç¥ç§˜å­¦ä»£ç çš„ä½œç”¨ä¸‹ï¼Œæ—§é¡µè¡¨æˆåŠŸåœ°å®ç°äº†ä¸ºçº¿æ€§åœ°å€ 0 æ˜ å°„äº†ç‰©ç†é¡µé¢ã€‚

ç”±ä¹‹å‰çš„è°´è´£å¯ä»¥å¾—çŸ¥ï¼Œå’±çš„ kernel æ˜¯å‹æ ¹æ²¡æœ‰è®¿é—®çº¿æ€§åœ°å€ 0 çš„å»å¤„çš„ï¼Œè¿™ 0 çš„æ˜ å°„è¦ä¹ˆæ˜¯æ—§é¡µè¡¨çš„é”™è¯¯æ˜ å°„ï¼Œè¦ä¹ˆæ˜¯ loader é˜¶æ®µå»ºç«‹çš„æ˜ å°„æ²¡æœ‰æ¸…é™¤â€”â€”æˆ–è€…è¯´ï¼Œ**å¦‚æ¸…é™¤**ã€‚

äºæ˜¯åˆ°äº† console çš„å®ç°é‡Œï¼Œå°±ä¼šå‡ºç°è¿™ä¹ˆä¸€ä¸ªåŒªå¤·æ‰€æ€çš„ BUGï¼šåœ¨çœ‹ä¸Šå»ååˆ†æ­£ç¡®çš„åŠŸèƒ½å®ç°ä¸‹ï¼Œå½“ console éœ€è¦ç¿»é¡µæ—¶ï¼Œå®ç°åˆ†æ˜æ­£ç¡®æ‹·è´ç¿»é¡µäº†ï¼Œå¯å±å¹•ä¸Šå´ååä¼šå…œå…œè½¬è½¬ç»•ä¸€åœˆå°†æœ€åˆçš„ç¬¬ 0 è¡Œæ‰€åœ¨çš„é‚£ä¸€å±é‡æ–°æ‰“å°å‡ºæ¥ã€‚

è«éæ˜¯åœ¨è¿™å®ç°çš„æŸä¸ªè§’è½é‡Œå­˜åœ¨æéš¾å¯Ÿè§‰çš„åæ ‡è®¾ç½®é—®é¢˜ï¼Œä½¿å¾—å®ƒå‘¨æœŸæ€§ç¿»è½¬äº†ï¼Ÿåˆæˆ–è€…å¹²è„†æ˜¯æ²¡æœ‰æ¸…ç©ºæ˜¾å­˜ï¼Ÿ

ä¸æ™“å¾—ï¼Œæ—¶é—´æœ‰é™ï¼Œåœ¨å‰æœŸç²—æµ…ä¿®äº† tty ä¾¿æ²¡å†å»ç®¡è¿™ console äº†ï¼Œæ¯•ç«Ÿæ˜¯æ— ä¼¤å¤§é›…çš„äº‹æƒ…ã€‚

å¯æ˜¯åœ¨æœ€æ–°çš„é¡µè¡¨å…¨é¢é‡å†™åï¼Œä¸€äº›æ–°çš„èœœæ±é—®é¢˜å´åˆè¹¦äº†å‡ºæ¥ã€‚å…³äºæ­¤å‰æ–‡å·²æœ‰æ ·ä¾‹ï¼Œä½†æ­¤å¤„ä¸”å°±å•å•ç›¯ç€è¿™ consoleï¼Œæ¥ä¸€æ¬¡æ—§æ´»æ–°æ•´ã€‚

**è¯·ï¼Œå†çœ‹å®ƒä¸€çœ¼ï¼**

```c
static void w_copy(unsigned int dst, const unsigned int src, int size) {
    memcpy(
        (void*)(V_MEM_BASE + (dst << 1)),
        (void*)(V_MEM_BASE + (src << 1)),
        size << 1);
}
```

**å†æ¥ç…ç…åˆ«ä¸ªå»å¤„ï¼Ÿ**

```c
static void clear_screen(int pos, int len) {
    u8* pch = (u8*)K_PHY2LIN(V_MEM_BASE + pos * 2);
    while (--len >= 0) {
        *pch++ = ' ';
        *pch++ = (u8)DEFAULT_CHAR_COLOR;
    }
}
```

> é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿ

MLGB çš„ï¼Œè¿™æ˜¾å­˜åŸºå€åˆ†æ˜å°±ä¸æ˜¯ä¸ªçº¿æ€§åœ°å€å•Šï¼

> é‚£ä»–ä¸ºä»€ä¹ˆèƒ½è®¿é—®å‘¢ï¼Ÿ

æ—§é¡µè¡¨æœ‰å¤§ææ€–å•Šï¼Œä»–æé‚£çº¿æ€§åœ°å€ 0 é™„è¿‘çš„åœ°æ–¹æœ‰é¡µè¡¨é¡¹ï¼Œ**æ°å·§**è®¿é—®ä¸ä¼šç¼ºé¡µå‘€ï¼

> é‚£å²‚ä¸å°±æ˜¯è¯´ï¼Ÿâ€”â€”

æ˜¯ææ˜¯æï¼è¿™ç©æ„å‹æ ¹å†™çš„å†…å­˜å°±ä¸å¯¹ï¼Œåªä¸è¿‡æ°å¥½æ²¡åŸåœ°çˆ†ç‚¸å‡å¤©ç½¢äº†ï¼å†çœ‹é‚£åŠŸèƒ½å®ç°â€”â€”æ“ä½œéƒ½æ“ä½œåˆ°åˆ«äººå®¶é‡Œå»äº†ï¼Œæ²¡è¢«äººå®¶æ‰“æ­»å·²æ˜¯è¸©äº†ç‹—å±è¿ï¼Œå“ªé‡Œè¿˜æ•¢è‹›æ±‚ä¸ªå¯Œè´µï¼

w_copyï¼Ÿå‘µï¼**å¦‚è°ƒç”¨**ç½¢äº†ï¼

ä¸è¿‡è¯åˆè¯´å›æ¥ï¼Œå°†è¿™åœ°å€è½¬æ¢äº†å»ï¼Œå†…æ ¸å¤„çš„çº¿æ€§åœ°å€ä¾¿æ˜¯å¯¹å—ï¼Ÿ

ç¡®å®ï¼Œè®¿å­˜ä¸€è‡´äº†ï¼Œé¡µè¡¨é¡¹æ­£ç¡®äº†ï¼ŒåŠŸèƒ½ç­‰è¯¸å¤šæ–¹é¢ä¹Ÿç€å®æ˜¯æ— è¯¯äº†ã€‚

å¯è«è¦å¿˜äº†è¿™ VGA æ˜¾å­˜çš„åŸºå€ä¸º 0x000b8000ï¼Œå¦‚ä»Šå´è¦æ•™è¿™è¯¸å¤šå¤–å› è½¬æ¢å»äº† 0xc00b8000ï¼Œå¦‚æ­¤ä¾æ—§æ˜¯å¯¹å—ï¼Ÿ

å¤§æŠµæ˜¯ä¼—å£éš¾ä¸€ã€‚

æˆ‘æ˜¯è§‰å¾—ï¼Œæ—¢ç„¶å·²ç»å°†è¿™è§„çŸ©æ‰“ç ´ï¼Œè¦ä¹ˆä¾¿ç ´ç¢ä¸ªå½»åº•ï¼Œè®©ç€åŸºå€éšæ³¢é€æµï¼Œè«è¦å†èµ–çš®ç€ä¸ª 0x000b8000ï¼›è¦ä¹ˆå°±æŠŠè§„çŸ©é‡æ–°æ ‘ç«‹å¥½ï¼Œå°†è¿™ 0x000b8000 ç»™å¥½å¥½æ˜ å°„åˆ°é‚£ä¸€èˆ¬æ¨¡æ ·çš„çº¿æ€§åœ°å€ï¼Œåˆ«å†æ•´ä¸ª**åƒç€ç¢—é‡Œï¼Œçœ‹ç€é”…é‡Œ**çš„ç¬‘è¯äº†ï¼

# å™©æ¢¦å°æ’æ›²ï¼Œå†…å­˜ææ…Œ

> from ???

```c
404 Not Found
```

æŒ‰ç…§ denounce çš„è¯„åˆ¤æ ‡å‡†æ¥è¯´ï¼Œè¿™ä¸€æ®µå…¶å®ä¸åº”è¯¥è¢«åŒ…å«è¿›æ¥ï¼Œä½†æ˜¯å®åœ¨æ˜¯æ†‹ä¸ä½äº†ï¼Œä¸é¡ºå¸¦æä¸€å˜´å¿ƒé‡Œå µå¾—æ…Œã€‚

miniOS çš„åŸºå‡†ä»£ç ä¸­è´´å¿ƒåœ°é™„ä¸Šäº†å†…å­˜æ¨¡å‹ï¼Œä½†æ®Šä¸çŸ¥è¿™æ­£æ˜¯å™©æ¢¦çš„å§‹ä½œä¿‘è€…ã€‚

å…ˆè´´å‡ ä¸ªè¡¥å……äº‹å®ï¼š

1. å¯ä»¥ä¸ºé“¾æ¥å™¨æŒ‡å®šå„ä¸ªæ®µçš„åŸºåœ°å€
2. é™æ€å¯é‡å®šå‘æ–‡ä»¶å„ä¸ªç¬¦å·çš„ç›¸å¯¹å®šä½æ˜¯å›ºå®šçš„ï¼Œæ— æ³•æˆ–è€…è¯´éš¾ä»¥æ‰‹åŠ¨æŒ‡å®š
3. é»˜è®¤æƒ…å†µä¸‹ï¼Œé“¾æ¥å™¨æŒ‰ç»™å‡ºçš„ç›®æ ‡æ–‡ä»¶åˆ—è¡¨çš„é¡ºåºè¿›è¡Œé“¾æ¥æ“ä½œ
4. å¯¹äºæ¯ä¸€ä¸ªç›®æ ‡æ–‡ä»¶ï¼Œé“¾æ¥å™¨åœ¨å¯¹åº”æ®µä¸Šé¡ºåºå®šä½ï¼Œå…ˆé“¾æ¥çš„åœ¨æ®µçš„ä½åœ°å€å¤„ï¼Œåé“¾æ¥çš„åœ¨æ®µçš„é«˜åœ°å€å¤„
5. å¯ä»¥å¼ºåˆ¶æŒ‡å®šç¬¦å·çš„åœ°å€ï¼Œä½†è¿™ä¸ä¼šå½±å“å…¶ä½™ç¬¦å·çš„é‡å®šä½ï¼Œè‹¥ç¬¦å·å¯¹åº”çš„æ•°æ®åŒºé—´å­˜åœ¨é‡å ï¼Œå¯èƒ½å¼•å‘ä¸å¯é¢„ä¼°çš„é”™è¯¯

å¥½äº†ï¼Œå†å›åˆ°åŸºå‡†ä»£ç ã€‚

åœ¨è®¾è®¡ä¸­ï¼Œloader è¢«åŠ è½½åˆ°ç‰©ç†åœ°å€ 0x00090000 å¤„ï¼Œè€Œ kernel elf å°†è¢«åŠ è½½åˆ°ç‰©ç†åœ°å€ 0x00080000 å¤„ã€‚

å†…æ ¸çš„ text æ®µåŸºå€æŒ‡å®šä¸º 0xc0030400ï¼Œåœ¨å†…å­˜æ¨¡å‹ä¸­ï¼Œkernel runtime çš„å†…å­˜åŒºé—´è¢«ç¼–æ’åœ¨ 0x00030000\~0x00080000ï¼Œä¹Ÿå³ elf æ®µçš„å®‰å…¨åŠ è½½åŒºé—´åº”è¯¥åœ¨ 0xc0000400\~0xc0080000ã€‚

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œkernel çš„ elf åŠ è½½å¤šå°‘è°è¯´äº†ç®—ï¼Ÿå†…å­˜æ¨¡å‹è¯´äº†ä¸ç®—ï¼Œelf è‡ªå·±è¯´äº†ç®—ã€‚

åˆå§‹çš„å†…æ ¸æ ˆåœ¨ bss æ®µä¸­å®šä¹‰ï¼Œä¹Ÿå³åœ¨ text å’Œ data æ®µä¹‹åã€‚

è‹¥ä¸åšé¢å¤–çš„å¤„ç†ï¼Œä¹Ÿå³ textã€dataã€bss ä¸‰ä¸ªæ®µæ˜¯ç´§é‚»çš„ï¼Œå‡å®šç³»ç»Ÿä¸¥æ ¼æŒ‰ç…§ç»™å‡ºçš„å†…å­˜æ¨¡å‹æ“ä½œï¼Œé‚£ä¹ˆå…¶ç¨³å®šè¿è¡Œçš„å……åˆ†æ¡ä»¶åº”å½“æ˜¯**å†…å­˜æ¨¡å‹æ­£ç¡®**ã€‚

é‚£ä¹ˆå®ƒæ­£ç¡®å—ï¼Ÿå‰é¢æåˆ°äº†ï¼Œè¿™äº‹å¾—ç”± elf è¯´äº†ç®—ã€‚

loader çš„èµ·å§‹åœ°å€é™„è¿‘å­˜å‚¨äº† gdtï¼Œè¯¥éƒ¨åˆ†å°†åœ¨ kernel ä¸­è¢«æ‹·è´è‡³å†…æ ¸ç©ºé—´ï¼Œåˆ°æ­¤ loader çš„ä»»åŠ¡å½»åº•ç»“æŸï¼Œå…¶å†…å­˜ç©ºé—´å¯ä»¥è‡ªç”±ç”¨äºå…¶å®ƒç”¨é€”ã€‚

è€Œæ”¾ç½® kernel.bin çš„åŒºé—´ï¼Œç”±äº load æ®µçš„åŠ è½½åœ°å€ç´§å¯†æ’åˆ—ï¼Œæ‰€ä»¥ kernel elf åŠ è½½è‡³å†…æ ¸ç©ºé—´æ—¶ä¸€å®šä¸å­˜åœ¨å·®é”™ã€‚

å¯ loader å°±ä¸ä¸€æ ·äº†ï¼Œæ”¾ç½® kernel.bin çš„å†…å­˜ç©ºé—´è¢«è¦†å†™ä¹Ÿæ— æ‰€è°“ï¼Œå› ä¸ºåŠ è½½ä¸€å®šæ˜¯æ­£ç¡®çš„ï¼Œå¯ loader çš„ä»»åŠ¡è¦çº¦è«æ‰§è¡Œåˆ° kernel_main æ‰ç®—ç»“æŸï¼Œåœ¨è¿™ä¹‹å‰å¯¹ loader å†…å­˜ç©ºé—´çš„ä»»æ„éæ³•å†…å­˜å†™éƒ½æ˜¯æ½œåœ¨çš„è‡´å‘½å› ç´ ã€‚

é‚£ä¹ˆå¦‚æœ elf ä¸­ load æ®µçš„ç¬¦å·è¶Šè¿‡äº† 0xc0090000 ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿå°†ä¼šä¸ loader é‡å ï¼å¹¶ä¸”å°†ç›´æ¥é‡å  loader ä¸­å¾…è¢«æ‹·è´çš„ gdt æ•°æ®æ®µï¼

å¦‚æœè¶Šè¿‡çš„æ˜¯ text æˆ– data æ®µï¼Œé‚£ä¹ˆ gdt å°†è¢«ç›´æ¥ç ´åã€‚

ä½†ç›¸å¯¹äº text æˆ– data æ®µï¼Œbss æ®µæ˜¾ç„¶æ›´å®¹æ˜“è¶Šè¿‡ loader çš„å†…å­˜ç©ºé—´ã€‚å¹¶ä¸”ç”±äºäº§ç”Ÿäº `resb` çš„ bss æ®µç¬¦å·ä¸æ¸…ç©ºçš„å¤„ç†ï¼Œè¦†å†™çš„é—®é¢˜å°†æ›´åŠ éšè”½ã€‚æˆ–è®¸ç«‹å³è¢«å†™ï¼Œæˆ–è®¸å»¶è¿Ÿä¸€æ®µæ—¶é—´è¢«å†™ï¼Œåˆæˆ–è®¸æ°¸è¿œéƒ½ä¸ä¼šè¢«å†™ã€‚åœ¨åä¸¤ç§æƒ…å½¢ä¸‹ï¼Œå‡ºç°é—®é¢˜æ—¶è°ƒè¯•çš„éš¾åº¦è¿œè¿œé«˜äºå‰è€…ï¼Œç­‰é—®é¢˜å‡ºç°æ—¶ï¼Œä¸Šä¸‹æ–‡å¤§æ¦‚å¾€å¾€æ˜¯â€œè²Œä¼¼â€ä¸çœŸæ­£æœ‰é—®é¢˜çš„åœ°æ–¹å…«ç«¿å­æ‰“ä¸ç€ã€‚

> loader ä¸­å°† 0xc0000000 æ˜ å°„è‡³ç‰©ç†åœ°å€ 0x00000000

è¿™æ—¶å€™å†å›è¿‡å¤´æ¥çœ‹çœ‹**è¡¥å……äº‹å®çš„ç¬¬ 4 ç‚¹**ï¼šåœ°å€ä¾æ®é“¾æ¥æ¬¡åºé¡ºåºç¼–æ’ã€‚

åœ¨åŸå§‹çš„ Makefile é‡Œï¼Œkernel.asm è¢«å®‰æ’åœ¨ç¬¬ä¸€ä¸ªé“¾æ¥é¡¹ï¼Œæ ˆåŒºè¢«å®‰æ’åœ¨æ­¤ç›®æ ‡æ–‡ä»¶çš„ bss æ®µåç§» 0 ä½ç½®ï¼Œä¹Ÿå³åœ¨åŠ è½½æ—¶ä¼šè¢«åŠ è½½åˆ° kernel.bin bss æ®µçš„åŸºå€ä¸Šã€‚

ç°åœ¨çš„ kernel å¹¶ä¸é‚£ä¹ˆå¤§ï¼Œbss åŸºå€å‡ ä¹æ€»æ˜¯å¯ä»¥è½åœ¨ 0xc0040000 é™„è¿‘çš„åœ°æ–¹ã€‚

å¯å¦‚æœ kernel.asm çš„ç›®æ ‡æ–‡ä»¶è¢«æœ€åé“¾æ¥å‘¢ï¼Ÿåœ¨ `uniform-minios >= 0.5.1` çš„æŸä¸€ä¸ªç‰ˆæœ¬ä¸­ï¼Œå†…æ ¸æ ˆé¡¶ç›´æ¥å¹²åˆ°äº† 0xc0090140 å·¦å³çš„ä½ç½®ï¼Œè€Œ loader ä¸­çš„ gdt åŸºå€åˆ™æ˜¯ 0x90102â€”â€”ä»–ä»¬æ˜¯åœ¨ä¸€ä¸ªç‰©ç†é¡µé¢ä¸Šï¼

è¿™æ„å‘³ç€ä»€ä¹ˆï¼Ÿå¯èƒ½æ— äº‹å‘ç”Ÿï¼Œä¹Ÿå¯èƒ½åªä¸è¿‡æ˜¯ä¸€ä¸ª call æŒ‡ä»¤æŠŠè¿”å›åœ°å€å‹æ ˆï¼Œgdt å°±è¢«å†™äº†ï¼

å¦‚æœè¿™ä»¶äº‹åœ¨ gdt æ‹·è´å®Œæˆä¹‹å‰å‘ç”Ÿï¼Œé‚£ä¹ˆåŠ è½½äº†é”™è¯¯çš„ gdt ä¼šå‘ç”Ÿä»€ä¹ˆç®€ç›´éš¾ä»¥æƒ³è±¡ã€‚

å¯èƒ½æ˜¯ç›´æ¥åå¤å¹²ç©¿ biosï¼Œä¹Ÿå¯èƒ½åªæ˜¯æ— äº‹å‘ç”Ÿï¼Œæ›´å¯èƒ½æ˜¯å¹²ç©¿ä¸€æ¬¡ bios åç„¶ååˆæ— äº‹å‘ç”Ÿåœ°æ­£å¸¸è¿›å…¥ kernel_mainã€‚

> ä»¥ä¸‹çœç•¥ä¸‰åƒå­—â€¦â€¦

è¿™ä¸ªé—®é¢˜å¥½è§£å†³å—ï¼Ÿæ„è¯†åˆ°æ˜¯ gdt å‡ºé—®é¢˜äº†ï¼Œé‚£ç®€ç›´ä¸è¦å¤ªç®€å•ï¼Œloader gdt çš„åœ°å€æ˜¯å›ºå®šçš„ï¼Œç›´æ¥ gdb æ‰“ä¸ª watch åˆ†åˆ†é’Ÿå°±èƒ½å®šä½è¦†å†™ gdt çš„ä½ç½®ã€‚å¯è¦æ˜¯æ²¡æœ‰æ„è¯†åˆ°ï¼Œé‚£å¯å°±çœŸæ˜¯æ€€ç–‘å¤©æ€€ç–‘åœ°æ€€ç–‘ç©ºæ°”ï¼Œå‡ºé”™ä»£ç é™„è¿‘çš„ç©æ„ä½†å‡¡æ²¾äº²å¸¦æ•…çš„éƒ½å¾—é€šé€šæ’æŸ¥è¿‡å»ã€‚

> å½“ç„¶å¦‚æœå¯¹æ•´ä¸ªç³»ç»Ÿå…·æœ‰æå¼ºæŒæ§åŠ›å’Œæé«˜è‡ªä¿¡å¿ƒï¼Œé‚£å°±ç®—ä¸€å¼€å§‹æ²¡æ„è¯†åˆ° gdt çš„é—®é¢˜ä¹Ÿåº”è¯¥èƒ½ç¬¬ä¸€æ—¶é—´æ’é™¤æ‰å¤§éƒ¨åˆ†å¯èƒ½ã€‚

æˆªè‡³ v0.6.0ï¼Œuniform ä¾æ—§**æš‚æ—¶**æ²¡æœ‰ä¼˜é›…çš„åŠæ³•å¤„ç†è¶Šç•Œçš„é—®é¢˜ï¼Œè€Œæ˜¯ç®€å•åœ°å¼ºåˆ¶ kernel.asm é¦–å…ˆè¢«é“¾æ¥æ¥å…ˆç¼“å’Œä¸‹é—®é¢˜ï¼Œå‡‘æ´»è¿‡è¿‡æ—¥å­ã€‚

æ€»ä¸èƒ½ï¼Œæ¯æ¬¡ kernel å¤§å°å˜äº†æˆ‘éƒ½è¦äººåŠ›ç…ä¸€çœ¼å†åˆ°å¤„çˆ†æ”¹å¸¸é‡å§ï¼Ÿ

é‚£å¯çœŸæ˜¯â€”â€”æ—¢æ€ æƒ°åˆä¸ä¼˜é›…ã€‚

# éœ‡æƒŠï¼è‘—åç§‘å­¦å®¶ğŸ’©æŸäººç«Ÿå‘æ˜äº†å²æ— å‰ä¾‹çš„å®Œå…¨ä¸²è¡Œè°ƒåº¦ç®—æ³•ï¼Œè¿™ç©¶ç«Ÿæ˜¯â€¦â€¦ï¼Œè¿˜æ˜¯â€¦â€¦ï¼Œåé¢å¿˜äº†

> from proc.c:schedule

```c
void schedule() {
    PROCESS* p;
    int      greatest_ticks = 0;
    if (p_proc_current->task.stat == READY && p_proc_current->task.ticks > 0) {
        p_proc_next = p_proc_current;
        return;
    }
    while (!greatest_ticks) {
        for (p = proc_table; p < proc_table + NR_PCBS; p++) {
            if (p->task.stat == READY && p->task.ticks > greatest_ticks) {
                greatest_ticks = p->task.ticks;
                p_proc_next    = p;
            }
        }
        if (!greatest_ticks) {
            for (p = proc_table; p < proc_table + NR_PCBS; p++) {
                p->task.ticks = p->task.priority;
            }
        }
    }
}
```

> å½“å‰ç‰ˆæœ¬çš„ schedule å·²ç»è½¬ç§»ä¸º schedule.c çš„ cherry_pick_next_ready_procï¼Œä»¥ä¸ŠåŸæ±åŸå‘³çš„ shit è¯·å‚è€ƒ v0.6.0-rc1 åŠä¹‹å‰çš„ç‰ˆæœ¬ã€‚

yield çš„è¯­ä¹‰æ˜¯æ¸…ç©ºæ—¶é—´ç‰‡å¹¶è°ƒåº¦ï¼Œschedule çš„è¯­ä¹‰æ˜¯ä¸æ¸…ç©ºæ—¶é—´ç‰‡å¹¶è°ƒåº¦ã€‚

ä½ è¿™ä¸ªç®—æ³•ï¼Œåªè¦å½“å‰è¿›ç¨‹è¿˜æœ‰æ—¶é—´ç‰‡å°±ä¸è°ƒåº¦æ˜¯ä»€ä¹ˆé¬¼ï¼ï¼ï¼ä¸è¦è®©æˆ‘çº ç»“äº†èœ—ç‰›çˆ¬è¡Œä¹äº¿äº¿å…‰å¹´çš„æ—¶é—´æ‰å†³å®šå§”å±ˆè‡ªå·±è§ç€è„¸ä¸»åŠ¨è°ƒç”¨ schedule çš„å¿ƒç†æ–—äº‰ä»˜è¯¸ä¸œæµå•Šå–‚æ··è›‹ï¼ä½ æ™“ä¸æ™“å¾—è¿™å¹´å¤´æˆ‘è¿™ä¹ˆä¸€ä¸ªå¨‡å¼±ç å­—å¥¶èŒå´½å€’è¿½å°å°ä»£ç æ˜¯å¤šä¹ˆå€’åå¤©ç½¡çš„äº‹å“‡ï¼

è€å¨˜å¹³æ—¶ï¼Œå¯æ˜¯åŠ¨åŠ¨æ‰‹æŒ‡å¤´å°±èƒ½è¿·å€’ä¸€ç‰‡ç—å¸… BUG çš„å­˜åœ¨å•Šï¼

ä»–æ˜¯æ€ä¹ˆâ€¦â€¦ä»–ï¼Œä»–ä»–ä»–â€”â€”ä»–ä»¬æ˜¯æ€ä¹ˆæ•¢çš„å‘€ï¼ï¼ï¼
