<div align="center">
    <font size="6">分组实验</font>
</div>

<div align="center">
    <font size="4">谷建华</font>
</div>
<div align="center">
    <font size="4">2024-11-21 v0.5</font>
</div>

# 实验说明

本实验为试点班课程大作业，或称 lab7，旨在于前期准备的基础上进一步深入实践主流操作系统的一些基本概念、技术或组件。

对于出色的实验成果，其部分代码将被整合到实验基准代码的主线当中，并有机会以某种形式出现在后续试点班同学的面前。

由于实验基准代码通常来自各届参与者的零碎整合，故而你可能会在项目各部分品鉴到风格、水平不一的实现，哪怕是极为致命的错误也并非是不可能存在的事。

你应当在整个实验过程中始终保持一定的怀疑态度，当发现问题时，务必积极在群里提出并与同学或助教讨论。

对于分组实验，该份基准代码仅发挥参考作用。

我们推荐你在完成小组任务时进行模块化设计，提供一个高内聚的精巧实现；也鼓励你积极改造，大刀阔斧地改良现存实现乃至整体结构，呈现你深入思考，谨慎推敲后给出的更优方案。

总之，放手去做吧！以漂亮地完成实验任务为基本目标，充分展现你的个人能力、经验以及在本次课程中习得和总结的成果！

# 实验要求

## 关于分组

分组实验依据当年情况，提供若干选题供大家选择。

请各位两人一组，选取一个实验题目进行实现，对于每个选题，至多只能有一个小组选中。

若当届参与人数为奇数，则多出的个人可以根据自身情况决定是否单独成组，并至多容许有一个小组由 3 人组成。

当然，如果你确实是一头孤狼，也可以申请单人成组，不过也请谨慎地估计实验难度和更为实际的工作量。

虽然在往届看似分组实则单干的情况并不稀罕，但我们还是鼓励你们进行 **切实** 的团队合作。

分组只是一个形式，请务必注意到助教通常并非残疾人，在这里，一荣不会俱荣。

## 关于实现

一言蔽之，我们期待的实现是 **这显而易见地表明了我们确实漂亮地实现了该功能**。

包括但不限于：

1. 功能 → 它能够在主要情形下按照语义正常工作
2. 健壮 → 它能够在边界情形下按照语义正常工作
3. 并发 → 它能够在高并发情形下按照语义正常工作
4. 性能 → 它能够在横向或纵向比较下更为高效地工作

> 部分语义可能需要依赖到基准程序并未实现的一些组件，对于这部分语义忽略即可，当然你可能还是需要考虑下忽略该语义后可能出现的异常情况

对于一个复杂系统，一般的 code review 并不能覆盖所有细节，注意到所有例外。再者我们也很难通过伸腿瞪眼法阅读你的代码从而发现你的优秀之处。

故而你必须慎重考虑测试程序的设计，通过切实的数据或其他结果和你精炼的介绍在最终答辩向我们充分展现你的成果。

**测试程序** 指代一切能够作出展示的片段，包括但不限于用户程序、系统调用、插桩分析、单元测试、黑盒测试、信息统计。

当然，对程序实现本身的逻辑分析也是不可少的，一些 **测试程序** 本身可能会表现得不够全面，但实际上它已经完成了对所有可达分支的覆盖。在这种情况下，假定你的 **测试程序** 确实完善，你必须要清晰地表明在你的 xxx 设计下，该 yyy 测试是有效且全面的。

具体表现为：我们伟大的 GOOD 可能会提出一些奇奇怪怪的问题，那可能是刁钻的，也可能是因为对你的设计不够清晰而提出的伪命题。你必须对你本身的实现足够清晰且自信，从而对其作出回答、辩驳或承认自己的不足。

## 关于给分

说实话，100\% 的实现程度挺难，但是不打紧，我们也不会丧心病狂到满分只能由完美无缺的实现拿到，你完全可以放轻松心态，从易到难逐步完成。

分组实验的给分包括工作量、代码质量、答辩表现、实验报告四个方面。

### 工作量

工作量包括工作时长、代码量、完成进度。

你可以安装 Wakatime 插件以统计你的工作时长，对于工作量，可以使用 tokei、scc 或其他工具统计 sloc。

完成进度可能需要你们在小组内自行排布规划，若有需要，可以在答辩时展示。

> 请注意，包含发呆 3 小时的写代码调试 4 小时，工作时长是 1 小时而不是 4 小时，根据助教本人实践，日 20hr 三年只达到过一次，对于一般的高强度作业，短期内日均 7\~11hr 是正常水平。

### 代码质量

代码质量较难评估，但你可以参考以下指标入手：

- 格式 → 命名规范、代码风格统一 → 记得随手格式化
- 文档 → 必要的注释、必要的文档 → 不要过度注释，也尽量避免该注释的不注释
- 结构 → 减少冗余与重复，代码逻辑清晰，不要用不必要的奇技淫巧

### 答辩表现

答辩表现包括展示效果和对提问的回答两方面，可以派一个人答辩，也可以轮番上阵。

答辩中必须清晰呈现小组各成员的分工情况以及实际的完成成果，这是我们获悉 **工作量** 的主要渠道。

### 实验报告

你需要在实验报告中说明个人工作量与主要成果，并对负责的部分进行详细阐述，尤其是深入分析。

个别在各次小实验的报告中“开摆”的同学请注意，或许这次实验对你就如小实验一般易如反掌，但也请清晰阐述关键部分并给出实现原理、注意事项等等，不要寥寥几句再贴几个代码就结束了。

其次，贴代码请请仅贴相关部分的关键片段，莫要甩一大片上来。

实验报告除了作为评分的关键部分外也同样会留档，请认真对待。

### 其他

除了以上四项，git commit 记录、小实验完成状况与大实验负责部分的代码比对、对本人负责部分的答辩表现也会纳入评分参考与造假与否的判断。

# 可选题目

## 实现线程相关功能

> 选题代号 **`thread`**

1. 参考 linux，实现 syscall clone，并将原本的 fork 实现重构为 clone 的上层封装
2. 实现创建、退出、阻塞执行
    - 利用 clone 实现 pthread_create
    - 实现 pthread_exit
    - 实现 pthread_join
3. 实现线程同步机制
    - 实现自旋锁 pthread_spin_\* 系列
    - 实现互斥锁 pthread_mutex_\* 系列
    - 视情况决定是否实现条件变量、临界区、读写锁等并发机制
4. 参考测试要点
    - 证明多个线程并发执行并且共享同一个地址空间，最好是能够让多个多线程的进程同时执行
    - 证明接口功能的实现符合语义要求
    - 证明实现的并发原语能够正确地完成线程间同步与互斥

说明：你的实现需要以 POSIX 的 pthread 为标准，若实现的语义有显著不同处，请指出并作说明。

[参考文档](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/)

## 实现信号机制

> 选题代号 **`signal`**

1. 实现 signal 系列系统调用
    - 实现 syscall kill，用于向指定进程发送信号
    - 实现 syscall sigaction，用于为指定信号设置用户态处理函数
    - 实现 syscall sigreturn，用于在执行完信号处理函数后告知内核处理结束
    - 实现 syscall sigprocmask，用于检查或修改当前进程的信号屏蔽集合
2. 参考测试要点
    - 证明用户程序能够正确注册信号处理函数
    - 证明用户程序能够正确响应信号并执行对应的处理函数
    - 证明用户程序能够正确接受和屏蔽信号
    - 证明其在并发场景下的正确性
    - 提供利用信号机制实现的进程同步演示程序
    - 提供利用信号机制实现的 shell 程序，使其能够向正在执行的前台程序发送信号

说明：你的实现需要以 POSIX 的 pthread 为标准，若实现的语义有显著不同处，请指出并作说明。

[参考文档](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/)

## 实现管道系统

> 选题代号 **`pipe`**

1. 实现 syscall pipe，用于创建管道文件描述符
2. 实现 syscall dup，用于为给定描述符引用的文件分配新的描述符
3. 实现 syscall dup2，用于将描述符重定向到给定描述符所引用的文件
4. 将管道系统引入 shell，使其能够完成进程间数据传输与重定向的功能
5. 参考测试要点
    - 实现父子进程间的管道数据传输，验证写满、读空等情况被正确处理
    - 验证特殊情况处理的正确性
        * 进程退出而没有关闭管道
        * 多组进程同时使用管道系统
    - 提供基于管道系统实现的进程间同步演示程序

说明：你的实现需要以 POSIX 的 pthread 为标准，若实现的语义有显著不同处，请指出并作说明。

[参考文档](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/)

## 实现跨进程通信

> 选题代号 **`ipc`**

1. 实现 syscall ftok，用于生成 IPC 键
2. 从消息队列或共享内存中任选一种 IPC 机制进行实现
3. 对于消息队列，实现发送、接收、删除等操作
    - 实现 syscall msgget，用于创建或打开消息队列
    - 实现 syscall msgsnd，用于向消息队列发送消息
    - 实现 syscall msgrcv，用于从消息队列接收消息
    - 实现 syscall msgctl，用于消息队列的控制
4. 对于共享内存，实现创建、映射、撤销等操作
    - 实现 syscall shmget，用于创建或打开共享内存
    - 实现 syscall shmat，用于将共享内存附加到当前进程
    - 实现 syscall shmdt，用于分离附加的共享内存
    - 实现 syscall shmctl，用于共享内存的控制
5. 参考测试要点
    - 证明实现的 IPC 方法能够一对一、一对多、多对一、多对多地正常工作
    - 实现相关 stat 方法，监测系统运行过程中 MQ/SHM 的使用情况

说明：你的实现需要以 POSIX 的相关文档为标准，若实现的语义有显著不同处，请指出并作说明。

说明：考虑到该任务的复杂度，你可以恰当地忽略部分无关语义，但请注意不要让这些缺失的语义干扰到最终实现的正确性。

[参考文档](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/)

## 实现虚拟文件系统

> 选题代号 **`vfs`**

1. 基准代码的 VFS 仅对 superblock 和 file 提供了相当粗暴草率的实现，请参考 linux 补全/重写 VFS 系统
    - 为 VFS 引入 inode 与 dentry 的设计
    - 提供 inode_operations 并接入已有的文件系统
    - 补全 VFS 接口的语义，使其并发安全
2. 参考测试要点
    - 证明 VFS 能够正确挂载多个 fs 或设备
    - 证明 VFS 能够查找并访问到正确的 fs 或设备
    - 证明 VFS 的各个接口能够通过对应 fs 或设备提供的 ops 执行预期的操作
    - 证明 VFS 接口的并发安全

说明：你可以在群文件中找到关于当前 VFS 设计的更多信息。

说明：基准代码中 fs 提供的操作接口是不可靠的，所以此处不要求你证明 VFS 访问 fs 全过程的并发安全，仅需证明 VFS 本身实现的相关部分的并发安全。当然，如果你愿意修复已有 fs 的若干问题，那可就太好了。

## 实现 EXT2 文件系统

> 选题代号 **`fs-ext2`**

1. 参考 EXT2 标准，实现 read write open close create 等 vfs 接口操作
2. 参考 EXT2 标准，尽可能多得实现其他功能
3. 参考测试要点
    - 并发读写，确保系统正常运行，证明并发操作下的数据完整性
        * 并发读写多个文件，包括随机读写、连续读写
        * 并发读写同目录下的多个文件
        * 并发读写单个文件
        * 并发创建、删除目录
   - 使用 mkfs.ext2 制作空的文件系统并挂载，证明 EXT2 文件系统的正确性
        * 在宿主机向文件系统写入一些目录和文件，证明 QEMU 下能够正确读取
        * 在 QEMU 下向文件系统写入一些目录和文件，证明宿主机能够正确读取

[参考文档](https://www.nongnu.org/ext2-doc/ext2.html)

## 实现基于内存的文件系统

> 选题代号 **`fs-ramfs`**

1. 在内核中开辟一段内存用于存放文件系统数据
2. 为 ramfs 选定并实现一个 fs
    - 任选一个文件系统作为 ramfs 的 fs，对其进行简单实现
    - 实现驱动支持，该实现应当能够较为轻易地支持多文件系统
3. 支持通过 vfs 接口对 ramfs 进行访问

说明：参考 linux 的 ramfs，ramfs 在系统层次上与磁盘类似，属于块设备，不同的是它不能持久化存储，当系统关闭时文件系统也被销毁。

说明：本任务自由度较高，测试程序按照实现情况进行编写，建议参考 EXT2 文件系统的测试要求，证明 ramfs 的正确性与并发安全。

## 实现内存分配算法

> 选题代号 **`buddy-slab`**

1. 实现 buddy 算法，以 4KB 为单位进行内存分配
2. 实现 slab 内存分配器，在 buddy 的基础上实现更细粒度的内存分配
3. 替换当前所有的内存分配相关方法为 buddy 与 slab 的实现，包括 kmalloc kfree malloc free malloc_phypage free_phypage
4. 参考测试要点
    - 证明分配与回收的正确性
        * 算法实现内部不存在内存泄漏情况
        * 不同大小的申请均能正常处理
        * 边界情况的申请能正常处理
    - 对随机分配、内存读写、内存回收进行高并发测试
    - 统计性能与内存碎片等信息

## 实现 CFS 调度策略和增量式 sleep

> 选题代号 **`cfs-sleep`**

1. 实现 CFS 调度策略
    - 参考 linux，实现完全公平调度算法
    - 实现 syscall nice，控制不同进程的分配时间片的权重
2. 实现增量式 sleep，维护睡眠队列的等待增量
    - 实现 O(1) 的弹出操作
    - 实现 O(n) 的插入操作
3. 参考测试要点
    - 创建多个进程，设置每个进程的 nice 值，观察调度的变化
    - 对每个进程进行信息统计，包括进程的 nice 值、运行时间等
    - 让多个进程使用增量式 sleep 等待不同的时间，观察它们被唤醒的时间顺序
    - 在大规模并发的情况下运行程序，观察 CFS 调度和增量式 sleep 的性能表现

## 实现缺页中断处理

> 选题代号 **`pf-handler`**

1. 实现写时复制 COW 机制
    - 修改 syscall fork，使子进程不完全复制父进程内存信息而是与其内存共享，但是对应的物理页权限修改为只读
    - 进程因对共享内存执行写操作而触发 PF，修改处理函数使其在该情形下完成写时复制
2. 实现延迟加载 Lazy Load 机制
    - 启动用户程序时，只加载部分的 ELF 程序就直接开始执行
    - 进程因 ELF 未加载完全导致缺页而触发 PF，修改处理函数使其在该情形下完成延时加载
3. 参考测试要点
    - 证明 COW 的正确性
        * 多次 fork 和 exec 后进程能够正常地并发执行
        * 子进程退出后父进程能够保持正常执行
    - 证明 CoW 的有效性
        * 在内核中增加统计信息，统计缺页的次数和类型
        * 编写申请大量内存但不对其进行写操作的程序，对其进行 fork，使其当禁用 COW 时报错内存不足，而当启用 COW 后能够正常运行
    - 证明延迟加载的正确性
    - 证明延迟加载的有效性
        * 在内核中增加统计信息，统计缺页的次数和类型
        * 编写静态数据庞大的程序，计量并对比启用延迟加载前后加载并执行的时间差异

## 实现块设备缓冲区管理

> 选题代号 **`blkdev-buffer`**

1. 为磁盘 IO 引入缓冲区机制
    - 以 4K 为单位创建数据缓冲区，用于临时存储磁盘的数据拷贝与读写结果
    - 对于通常情形，所有的读写操作均在缓冲区完成
    - 当缓冲区满时，将对应的数据写回磁盘
    - 当需要强制刷新时，将对应的数据写回磁盘
2. 参考测试要点
    - 证明对于任意读写操作，缓冲区中的数据缓存总是有效的
        * 进行大量随机读写，验证写出、读入的内容与磁盘实际内容一致
    - 证明极端情形下缓冲区实现的正确性
        * 大量数据的连续读写
        * 跨度较大的随机读写
    - 证明缓冲区的实现并发安全
    - 增加统计信息，证明缓冲区对于性能提升的有效性

说明：当前基准代码中对于磁盘访问的缓冲区管理可以说是几乎没有，遇到一个请求就向磁盘读写，需要发起大量的 IO 操作，极为耗时。相比于直接读写物理设备，内存读写明显快得多得多，这就是缓冲区存在的必要性。

## 实现网络通讯

> 选题代号 **`drv-net`**

1. 实现数据链路层驱动，使其能够向宿主机或其他终端发送 MAC 帧，目的终端应能够成功接收到数据并作出应答
2. 实现系统调用或其他形式的接口，使其能够动态配置网卡
3. 视自身情况，实现任意协议，使其能够与另一台终端相互收发数据

说明：本任务自由度较高，测试程序按照实现情况进行编写，但由于本任务的成果看上去可能会比较单薄，所以请额外注重演示效果。

## 实现图形化界面

> 选题代号 **`graphics`**

1. 实现一个简单的窗口管理器 WM
    - 支持窗口的创建与销毁
    - 支持窗口的移动
    - 支持窗口的最大化、最小化
    - 支持窗口的大小调整
    - 支持窗口的 z-order 处理
    - 实现任意机制，使得窗口实例能响应 WM 发起的控制，如消息队列
2. 实现鼠标交互
    - 实现鼠标的实时绘制
    - 实现 HITTEST 算法，使 WM 能够正确处理鼠标事件并通知命中的窗口实例
3. 视自身情况，实现更多功能
    - 实现简易 GUI 框架并利用其实现基础控件，包括但不限于 Button Label CheckBox Edit Menu Image 等等
    - 实现键盘交互
    - 实现焦点机制

说明：鉴于目前 OS 依赖的是 BIOS 主板，因此图形化界面只能使用 VGA 或 VBE 实现。

说明：如果能采用 AGP 或 PCI-E+DMA 实现帧缓冲数据的高速传输，那么你将会获得更好的成绩。

说明：实现图形界面有部分开源程序 miniGUI、openGUI 等，其他具有图形界面的开源操作系统项目也极具参考价值。

说明：本任务自由度较高，测试程序按照实现情况进行编写，以基本功能演示和花里胡哨的炫技两方面为主。

[参考文档](https://wiki.osdev.org/Drawing_In_a_Linear_Framebuffer)

## 实现对多架构的支持

> 选题代号 **`multiarch`**

1. 选定 i386 以外的架构进行移植并配置对应的交叉编译环境，建议选择 32-bit 的 ARMv7-A
2. 研究并设计新的项目结构，使得项目能够同时支持多个架构
    - 修改 Makefile，使得项目能够直接构建指定 arch 的 os 镜像
    - 抽取并区分出架构相关代码和架构无关代码
        * 对于架构无关的实现，使其能够最大程度地复用
        * 对于架构相关的实现，使其能够向架构无关代码暴露相同的接口
3. 为新 arch 复刻 bootloader 以及 kernel 的架构相关部分
4. 实现硬件抽象层 HAL，使得不同架构能够以相同的 API 访问硬件
5. 参考测试要点
    - 证明进行多架构移植后，系统能够正确运行于原 i386 架构
    - 证明 HAL 的正确性与有效性
        * 对于架构无关部分，所有硬件访问均由 HAL 完成
        * 引入 HAL 前后，各类硬件访问的行为一致
    - 证明对于系统的各功能，各个架构具有相同或在语义容许范围内相似的行为
        * 常规逻辑
        * IO 操作
        * 系统调用
        * 并发场景
