# 摘要

本文档提供给当届试点班的各位同学，就使用的 uniform-minios 基准代码作若干说明，主要包括项目整体介绍、框架实现和实验注意事项，希望能对大家有所帮助。

# 整体介绍

uniform-minios 是你瓜 GOOD 试点班原基准代码 miniOS-v1.3.2 于 2023 届试点班大实验给出的重制版本，提供了各种意义上更为赏心悦目的实现与相关基础设施支持。

其中小实验部分经过 2024 届的重置，已基本与 uniform 达成一致风格。但鉴于小实验改进的部分过多，uniform 并未能够及时引入小实验涉及到的全部更优实现，你有必要重新审视 uniform 的代码结构，发觉其与小实验不一致的若干处。

# 框架实现

## 特权级

uniform 将权限划分为了 KERNEL TASK USER 三个级别，分别对应 ring0 ring1 ring3。

其中 TASK 包含磁盘服务 hd_service、TTY 服务 tty_handler 以及回收进程 scavenger。

hd_service 负责处理磁盘请求，包括设备读写。

> hd_service 已经被我干掉了，但是为了方便你理解，我们假装它仍然存在。
>
> 关于详细情况请跳转到注意事项的相关小节。

tty_handler 负责处理 TTY 请求，包括 TTY 的创建、切换，以及输入输出操作。

其中 NR_CONSOLES 定义了最大可支持的 TTY 数量，你可以使用 F1 F2 等切换到对应的 TTY 上。

回收进程 scavenger 充当 idle 的角色，负责回收僵尸进程，并释放其占用的内存。

## 内存管理

内存管理主要在 memory 中实现，但是不同于内存分配器，memory 中实际上只提供了一个 allocator，详细来说是一个地址区间的分配器，其并不提供除了地址区间划分、分配与回收之外的一切事务。

malloc 等方法在 uniform 中的实现方法是，取得一个 allocator，再从 allocator 分配得到一块空闲地址段，对其进行页表映射等处理使其具备对应的 alloc 方法应当具备的语义。

当然，这么说可能有些多余，换做 buddy slab 的实现也是同样的道理。

总之最底层的 memory allocator 唯一的职责就是划分给你一块确保独占的地址区间，而调用方的职责则在于恰当地利用这块地址区间去做想做的事。

例如，分配为物理页，亦或者是对这块地址区间实现用户态的堆分配算法。

## 系统调用

所有系统调用首先在内核态被实现为 `do_*` 方法，其次通过 `sys_*` 统一封装后存入 syscall 查找表。

所有的 `do_*` 方法均 **唯一** 声明于 `syscall.h`，并在标注的对应位置提供实现。

当且仅当在 ring0 你需要使用 `do_*` 完成相关提供的操作，而在 ring1 ring3 你必须且只能使用系统调用。

# 注意事项

在开始之前，你非常有必要完成 clangd 的配置，这在各种意义上都有助于你理解代码和提高开发效率。

## 关于配置

请不要将系统始终频率调至 5kHz 以上，这会导致系统运行效率降低，并有极大概率产生异常错误。

## 关于特权级

uniform 中，并未像 lab5 lab6 那样彻底隔离用户态和内核态可访问的方法，从根本上杜绝了跨权限访问的问题，故而你必须要注意当前方法所运行的特权级，并注意不要越权访问。

在 uniform 中，USER 与 TASK 的主要区别在于 USER 只能访问 user space，而 TASK 默认访问 kernel space 且直接访问设备。

你会发现 TASK 的两个入口方法是定义在 kernel 中的，但是请务必注意，这并不意味着你可以随意操作 cr3 这些寄存器，如果你尝试这么做，则会光荣地得到 GP 等异常。

同理，在内核 ring0 下你也禁止使用 syscall，而应当调用其对应的 `do_*` 方法。

当你需要使用一些依赖方法是，你必须使用 include/lib 下的对应同文件，而不是 include/kernel 的对应方法。

具体到代码上来说，对于内核代码也即 ring0，你应当使用 `#include <unios/assert.h>`，而对于用户代码以及内核代码中运行在 ring1 的代码片段，你必须使用 `#include <assert.h>`。

你应当能够发现，他们最主要的区别其实是是否在 `unios/` 下。

## 关于符号

同上一小节，未彻底隔离的直接产物便是 librt 会和 kernel 一起链接。

在 lab6 中，因为隔离的存在，分别供用户态和内核态使用的同符号的方法并不会产生符号冲突，因为他们本身就被编译到了不同的库文件中。

而在 uniform 中，这些代码被编译到了同一个 librt 中，当你需要添加新的符号时，你必须要清楚该符号是仅在 kernel task 或 user 使用，还是三者都可以用，并谨慎地对其进行恰如其分地命名。

## 关于文件系统

详见 [关于镜像制作的若干说明](关于镜像制作的若干说明.md)。

## 关于磁盘读写

hd_service 不可信，它看似很重要但完全没有被使用到，详情可以见 denounce 的相关部分。

磁盘读写是被调用方直接接入的。

另一个值得注意的是，TTY 的读写操作是接入到文件读写一致的方法后再进行转发的。你可以一路跟踪到执行 TTY 读写实际操作的上一级调用方，那儿是一个非常丑陋的 if-else 语句。

## 关于清道夫与杀手兔

分别指代 scavenger 和 syscall killerrabbit，这是 uniform 整的抽象活，请不要在意。

杀手兔的作用是杀杀杀杀到血流成河。

清道夫进程如其名，职责就是食腐。

~~据小道消息，清道夫招聘了一位实力强劲的杀手兔，一个负责噶，一个负责吃，最终还了进程届一片朗朗乾坤。~~

总而言之，就是替代常规 0 号进程 idle 的作用，回收已经噶掉的僵尸进程。

> 别看我，我也不知道当时为什么会整出这么个玩意儿而不是实现为 idle，这你得问我的队友。细细想来，或许还是因为 23 届的大实验和小实验完全两模两样，导致脑子一下子没转过弯吧。
>
> 当然，也不排除我的队友只是单纯地想杀杀杀，不然也不会专门招聘一位杀手兔你说不是？

## 关于实现细节

基准代码并非所有部分都是 nice 的，只是当时为了赶进度选的最便捷的实现。

比如 getenv 和 malloc 不应该设计成系统调用而是在用户态实现。

比如 syscall krnlobject 系列完全就是为了处理输出互斥实现的 ipc 机制的下位替代。

总之，别思维僵化，多尝试，多创新，多思考，多改进。

## 关于注释

多瞅着点我留下的 TODO 和 FIXME，注意下标了这些玩意都是有明面上或潜在的问题的，别踩坑里了。

## 关于代码

文档写再多总有些人死活不看，所以遇到什么问题都给我去看代码！
